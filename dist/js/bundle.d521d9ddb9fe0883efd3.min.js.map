{"version":3,"file":"js/bundle.d521d9ddb9fe0883efd3.min.js","mappings":"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","sources":["webpack:///../node_modules/@ethersproject/providers/lib.esm/ws.js","webpack:///../node_modules/@ethersproject/providers/lib.esm/websocket-provider.js","webpack:///../node_modules/alchemy-sdk/dist/esm/alchemy-websocket-provider-35c345f7.js","webpack:///../node_modules/es5-ext/global.js","webpack:///../node_modules/sturdy-websocket/dist/index.js","webpack:///../node_modules/websocket/lib/browser.js","webpack:///../node_modules/websocket/lib/version.js"],"sourcesContent":["\"use strict\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nlet WS = null;\ntry {\n    WS = WebSocket;\n    if (WS == null) {\n        throw new Error(\"inject please\");\n    }\n}\ncatch (error) {\n    const logger = new Logger(version);\n    WS = function () {\n        logger.throwError(\"WebSockets not supported in this environment\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"new WebSocket()\"\n        });\n    };\n}\n//export default WS;\n//module.exports = WS;\nexport { WS as WebSocket };\n//# sourceMappingURL=ws.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\nimport { WebSocket } from \"./ws\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n/**\n *  Notes:\n *\n *  This provider differs a bit from the polling providers. One main\n *  difference is how it handles consistency. The polling providers\n *  will stall responses to ensure a consistent state, while this\n *  WebSocket provider assumes the connected backend will manage this.\n *\n *  For example, if a polling provider emits an event which indicates\n *  the event occurred in blockhash XXX, a call to fetch that block by\n *  its hash XXX, if not present will retry until it is present. This\n *  can occur when querying a pool of nodes that are mildly out of sync\n *  with each other.\n */\nlet NextId = 1;\n// For more info about the Real-time Event API see:\n//   https://geth.ethereum.org/docs/rpc/pubsub\nexport class WebSocketProvider extends JsonRpcProvider {\n    constructor(url, network) {\n        // This will be added in the future; please open an issue to expedite\n        if (network === \"any\") {\n            logger.throwError(\"WebSocketProvider does not support 'any' network yet\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"network:any\"\n            });\n        }\n        if (typeof (url) === \"string\") {\n            super(url, network);\n        }\n        else {\n            super(\"_websocket\", network);\n        }\n        this._pollingInterval = -1;\n        this._wsReady = false;\n        if (typeof (url) === \"string\") {\n            defineReadOnly(this, \"_websocket\", new WebSocket(this.connection.url));\n        }\n        else {\n            defineReadOnly(this, \"_websocket\", url);\n        }\n        defineReadOnly(this, \"_requests\", {});\n        defineReadOnly(this, \"_subs\", {});\n        defineReadOnly(this, \"_subIds\", {});\n        defineReadOnly(this, \"_detectNetwork\", super.detectNetwork());\n        // Stall sending requests until the socket is open...\n        this.websocket.onopen = () => {\n            this._wsReady = true;\n            Object.keys(this._requests).forEach((id) => {\n                this.websocket.send(this._requests[id].payload);\n            });\n        };\n        this.websocket.onmessage = (messageEvent) => {\n            const data = messageEvent.data;\n            const result = JSON.parse(data);\n            if (result.id != null) {\n                const id = String(result.id);\n                const request = this._requests[id];\n                delete this._requests[id];\n                if (result.result !== undefined) {\n                    request.callback(null, result.result);\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        request: JSON.parse(request.payload),\n                        response: result.result,\n                        provider: this\n                    });\n                }\n                else {\n                    let error = null;\n                    if (result.error) {\n                        error = new Error(result.error.message || \"unknown error\");\n                        defineReadOnly(error, \"code\", result.error.code || null);\n                        defineReadOnly(error, \"response\", data);\n                    }\n                    else {\n                        error = new Error(\"unknown error\");\n                    }\n                    request.callback(error, undefined);\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        error: error,\n                        request: JSON.parse(request.payload),\n                        provider: this\n                    });\n                }\n            }\n            else if (result.method === \"eth_subscription\") {\n                // Subscription...\n                const sub = this._subs[result.params.subscription];\n                if (sub) {\n                    //this.emit.apply(this,                  );\n                    sub.processFunc(result.params.result);\n                }\n            }\n            else {\n                console.warn(\"this should not happen\");\n            }\n        };\n        // This Provider does not actually poll, but we want to trigger\n        // poll events for things that depend on them (like stalling for\n        // block and transaction lookups)\n        const fauxPoll = setInterval(() => {\n            this.emit(\"poll\");\n        }, 1000);\n        if (fauxPoll.unref) {\n            fauxPoll.unref();\n        }\n    }\n    // Cannot narrow the type of _websocket, as that is not backwards compatible\n    // so we add a getter and let the WebSocket be a public API.\n    get websocket() { return this._websocket; }\n    detectNetwork() {\n        return this._detectNetwork;\n    }\n    get pollingInterval() {\n        return 0;\n    }\n    resetEventsBlock(blockNumber) {\n        logger.throwError(\"cannot reset events block on WebSocketProvider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"resetEventBlock\"\n        });\n    }\n    set pollingInterval(value) {\n        logger.throwError(\"cannot set polling interval on WebSocketProvider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"setPollingInterval\"\n        });\n    }\n    poll() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return null;\n        });\n    }\n    set polling(value) {\n        if (!value) {\n            return;\n        }\n        logger.throwError(\"cannot set polling on WebSocketProvider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"setPolling\"\n        });\n    }\n    send(method, params) {\n        const rid = NextId++;\n        return new Promise((resolve, reject) => {\n            function callback(error, result) {\n                if (error) {\n                    return reject(error);\n                }\n                return resolve(result);\n            }\n            const payload = JSON.stringify({\n                method: method,\n                params: params,\n                id: rid,\n                jsonrpc: \"2.0\"\n            });\n            this.emit(\"debug\", {\n                action: \"request\",\n                request: JSON.parse(payload),\n                provider: this\n            });\n            this._requests[String(rid)] = { callback, payload };\n            if (this._wsReady) {\n                this.websocket.send(payload);\n            }\n        });\n    }\n    static defaultUrl() {\n        return \"ws:/\\/localhost:8546\";\n    }\n    _subscribe(tag, param, processFunc) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let subIdPromise = this._subIds[tag];\n            if (subIdPromise == null) {\n                subIdPromise = Promise.all(param).then((param) => {\n                    return this.send(\"eth_subscribe\", param);\n                });\n                this._subIds[tag] = subIdPromise;\n            }\n            const subId = yield subIdPromise;\n            this._subs[subId] = { tag, processFunc };\n        });\n    }\n    _startEvent(event) {\n        switch (event.type) {\n            case \"block\":\n                this._subscribe(\"block\", [\"newHeads\"], (result) => {\n                    const blockNumber = BigNumber.from(result.number).toNumber();\n                    this._emitted.block = blockNumber;\n                    this.emit(\"block\", blockNumber);\n                });\n                break;\n            case \"pending\":\n                this._subscribe(\"pending\", [\"newPendingTransactions\"], (result) => {\n                    this.emit(\"pending\", result);\n                });\n                break;\n            case \"filter\":\n                this._subscribe(event.tag, [\"logs\", this._getFilter(event.filter)], (result) => {\n                    if (result.removed == null) {\n                        result.removed = false;\n                    }\n                    this.emit(event.filter, this.formatter.filterLog(result));\n                });\n                break;\n            case \"tx\": {\n                const emitReceipt = (event) => {\n                    const hash = event.hash;\n                    this.getTransactionReceipt(hash).then((receipt) => {\n                        if (!receipt) {\n                            return;\n                        }\n                        this.emit(hash, receipt);\n                    });\n                };\n                // In case it is already mined\n                emitReceipt(event);\n                // To keep things simple, we start up a single newHeads subscription\n                // to keep an eye out for transactions we are watching for.\n                // Starting a subscription for an event (i.e. \"tx\") that is already\n                // running is (basically) a nop.\n                this._subscribe(\"tx\", [\"newHeads\"], (result) => {\n                    this._events.filter((e) => (e.type === \"tx\")).forEach(emitReceipt);\n                });\n                break;\n            }\n            // Nothing is needed\n            case \"debug\":\n            case \"poll\":\n            case \"willPoll\":\n            case \"didPoll\":\n            case \"error\":\n                break;\n            default:\n                console.log(\"unhandled:\", event);\n                break;\n        }\n    }\n    _stopEvent(event) {\n        let tag = event.tag;\n        if (event.type === \"tx\") {\n            // There are remaining transaction event listeners\n            if (this._events.filter((e) => (e.type === \"tx\")).length) {\n                return;\n            }\n            tag = \"tx\";\n        }\n        else if (this.listenerCount(event.event)) {\n            // There are remaining event listeners\n            return;\n        }\n        const subId = this._subIds[tag];\n        if (!subId) {\n            return;\n        }\n        delete this._subIds[tag];\n        subId.then((subId) => {\n            if (!this._subs[subId]) {\n                return;\n            }\n            delete this._subs[subId];\n            this.send(\"eth_unsubscribe\", [subId]);\n        });\n    }\n    destroy() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Wait until we have connected before trying to disconnect\n            if (this.websocket.readyState === WebSocket.CONNECTING) {\n                yield (new Promise((resolve) => {\n                    this.websocket.onopen = function () {\n                        resolve(true);\n                    };\n                    this.websocket.onerror = function () {\n                        resolve(false);\n                    };\n                }));\n            }\n            // Hangup\n            // See: https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes\n            this.websocket.close(1000);\n        });\n    }\n}\n//# sourceMappingURL=websocket-provider.js.map","import { _ as __awaiter, f as fromHex, t as toHex, n as noop, C as CustomNetworks, i as isAlchemyEvent, v as verifyAlchemyEventName, c as EthersEvent, d as getAlchemyEventTag, D as DEFAULT_ALCHEMY_API_KEY, A as ALCHEMY_EVENT_TYPES, e as ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE, h as AlchemySubscription, j as ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE, V as VERSION, E as EthersNetwork } from './index-02af91ae.js';\nimport SturdyWebSocket from 'sturdy-websocket';\nimport { BigNumber } from '@ethersproject/bignumber';\nimport { getNetwork } from '@ethersproject/networks';\nimport { WebSocketProvider } from '@ethersproject/providers';\nimport { AlchemyProvider } from './alchemy-provider-a776ca8a.js';\nimport './api/utils';\nimport 'axios';\nimport '@ethersproject/abstract-provider';\nimport '@ethersproject/wallet';\nimport '@ethersproject/contracts';\nimport '@ethersproject/web';\n\n/**\r\n * The maximum number of blocks to backfill. If more than this many blocks have\r\n * been missed, then we'll sadly miss data, but we want to make sure we don't\r\n * end up requesting thousands of blocks if somebody left their laptop closed for a week.\r\n */\r\nconst MAX_BACKFILL_BLOCKS = 120;\r\n/**\r\n * The WebsocketBackfiller fetches events that were sent since a provided block\r\n * number. This is used in the {@link AlchemyWebSocketProvider} to backfill\r\n * events that were transmitted while the websocket connection was down.\r\n *\r\n * The backfiller backfills two main eth_subscribe events: `logs` and `newHeads`.\r\n *\r\n * @internal\r\n */\r\nclass WebsocketBackfiller {\r\n    constructor(provider) {\r\n        this.provider = provider;\r\n        // TODO: Use HTTP provider to do backfill.\r\n        this.maxBackfillBlocks = MAX_BACKFILL_BLOCKS;\r\n    }\r\n    /**\r\n     * Runs backfill for `newHeads` events.\r\n     *\r\n     * @param isCancelled Whether the backfill request is cancelled.\r\n     * @param previousHeads Previous head requests that were sent.\r\n     * @param fromBlockNumber The block number to start backfilling from.\r\n     * @returns A list of `newHeads` events that were sent since the last backfill.\r\n     */\r\n    getNewHeadsBackfill(isCancelled, previousHeads, fromBlockNumber) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            throwIfCancelled(isCancelled);\r\n            const toBlockNumber = yield this.getBlockNumber();\r\n            throwIfCancelled(isCancelled);\r\n            // If there are no previous heads to fetch, return new heads since\r\n            // `fromBlockNumber`, or up to maxBackfillBlocks from the current head.\r\n            if (previousHeads.length === 0) {\r\n                return this.getHeadEventsInRange(Math.max(fromBlockNumber, toBlockNumber - this.maxBackfillBlocks) + 1, toBlockNumber + 1);\r\n            }\r\n            // If the last emitted event is too far back in the past, there's no need\r\n            // to backfill for reorgs. Just fetch the last `maxBackfillBlocks` worth of\r\n            // new heads.\r\n            const lastSeenBlockNumber = fromHex(previousHeads[previousHeads.length - 1].number);\r\n            const minBlockNumber = toBlockNumber - this.maxBackfillBlocks + 1;\r\n            if (lastSeenBlockNumber <= minBlockNumber) {\r\n                return this.getHeadEventsInRange(minBlockNumber, toBlockNumber + 1);\r\n            }\r\n            // To capture all `newHeads` events, return all head events from the last\r\n            // seen block number to current + any of the previous heads that were re-orged.\r\n            const reorgHeads = yield this.getReorgHeads(isCancelled, previousHeads);\r\n            throwIfCancelled(isCancelled);\r\n            const intermediateHeads = yield this.getHeadEventsInRange(lastSeenBlockNumber + 1, toBlockNumber + 1);\r\n            throwIfCancelled(isCancelled);\r\n            return [...reorgHeads, ...intermediateHeads];\r\n        });\r\n    }\r\n    /**\r\n     * Runs backfill for `logs` events.\r\n     *\r\n     * @param isCancelled Whether the backfill request is cancelled.\r\n     * @param filter The filter object that accompanies a logs subscription.\r\n     * @param previousLogs Previous log requests that were sent.\r\n     * @param fromBlockNumber The block number to start backfilling from.\r\n     */\r\n    getLogsBackfill(isCancelled, filter, previousLogs, fromBlockNumber) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            throwIfCancelled(isCancelled);\r\n            const toBlockNumber = yield this.getBlockNumber();\r\n            throwIfCancelled(isCancelled);\r\n            // If there are no previous logs to fetch, return new logs since\r\n            // `fromBlockNumber`, or up to `maxBackfillBlocks` from the current head.\r\n            if (previousLogs.length === 0) {\r\n                return this.getLogsInRange(filter, Math.max(fromBlockNumber, toBlockNumber - this.maxBackfillBlocks) + 1, toBlockNumber + 1);\r\n            }\r\n            // If the last emitted log is too far back in the past, there's no need\r\n            // to backfill for removed logs. Just fetch the last `maxBackfillBlocks`\r\n            // worth of logs.\r\n            const lastSeenBlockNumber = fromHex(previousLogs[previousLogs.length - 1].blockNumber);\r\n            const minBlockNumber = toBlockNumber - this.maxBackfillBlocks + 1;\r\n            if (lastSeenBlockNumber < minBlockNumber) {\r\n                return this.getLogsInRange(filter, minBlockNumber, toBlockNumber + 1);\r\n            }\r\n            // Return all log events that have happened along with log events that have\r\n            // been removed due to a chain reorg.\r\n            const commonAncestor = yield this.getCommonAncestor(isCancelled, previousLogs);\r\n            throwIfCancelled(isCancelled);\r\n            // All previous logs with a block number greater than the common ancestor\r\n            // were part of a re-org, so mark them as such.\r\n            const removedLogs = previousLogs\r\n                .filter(log => fromHex(log.blockNumber) > commonAncestor.blockNumber)\r\n                .map(log => (Object.assign(Object.assign({}, log), { removed: true })));\r\n            // If no common ancestor was found, start backfill from the oldest log's\r\n            // block number.\r\n            const fromBlockInclusive = commonAncestor.blockNumber === Number.NEGATIVE_INFINITY\r\n                ? fromHex(previousLogs[0].blockNumber)\r\n                : commonAncestor.blockNumber;\r\n            let addedLogs = yield this.getLogsInRange(filter, fromBlockInclusive, toBlockNumber + 1);\r\n            // De-dupe any logs that were already emitted.\r\n            addedLogs = addedLogs.filter(log => log &&\r\n                (fromHex(log.blockNumber) > commonAncestor.blockNumber ||\r\n                    fromHex(log.logIndex) > commonAncestor.logIndex));\r\n            throwIfCancelled(isCancelled);\r\n            return [...removedLogs, ...addedLogs];\r\n        });\r\n    }\r\n    /**\r\n     * Sets a new max backfill blocks. VISIBLE ONLY FOR TESTING.\r\n     *\r\n     * @internal\r\n     */\r\n    setMaxBackfillBlock(newMax) {\r\n        this.maxBackfillBlocks = newMax;\r\n    }\r\n    /**\r\n     * Gets the current block number as a number.\r\n     *\r\n     * @private\r\n     */\r\n    getBlockNumber() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const blockNumberHex = yield this.provider.send('eth_blockNumber');\r\n            return fromHex(blockNumberHex);\r\n        });\r\n    }\r\n    /**\r\n     * Gets all `newHead` events in the provided range. Note that the returned\r\n     * heads do not include re-orged heads. Use {@link getReorgHeads} to find heads\r\n     * that were part of a re-org.\r\n     *\r\n     * @private\r\n     */\r\n    getHeadEventsInRange(fromBlockInclusive, toBlockExclusive) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (fromBlockInclusive >= toBlockExclusive) {\r\n                return [];\r\n            }\r\n            const batchParts = [];\r\n            for (let i = fromBlockInclusive; i < toBlockExclusive; i++) {\r\n                batchParts.push({\r\n                    method: 'eth_getBlockByNumber',\r\n                    params: [toHex(i), false]\r\n                });\r\n            }\r\n            // TODO: handle errors\r\n            const blockHeads = yield this.provider.sendBatch(batchParts);\r\n            return blockHeads.map(toNewHeadsEvent);\r\n        });\r\n    }\r\n    /**\r\n     * Returns all heads that were part of a reorg event.\r\n     *\r\n     * @private\r\n     */\r\n    getReorgHeads(isCancelled, previousHeads) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const result = [];\r\n            // Iterate from the most recent head backwards in order to find the first\r\n            // block that was part of a re-org.\r\n            for (let i = previousHeads.length - 1; i >= 0; i--) {\r\n                const oldEvent = previousHeads[i];\r\n                const blockHead = yield this.getBlockByNumber(fromHex(oldEvent.number));\r\n                throwIfCancelled(isCancelled);\r\n                // If the hashes match, then current head in the iteration was not re-orged.\r\n                if (oldEvent.hash === blockHead.hash) {\r\n                    break;\r\n                }\r\n                result.push(toNewHeadsEvent(blockHead));\r\n            }\r\n            return result.reverse();\r\n        });\r\n    }\r\n    /**\r\n     * Simple wrapper around `eth_getBlockByNumber` that returns the complete\r\n     * block information for the provided block number.\r\n     *\r\n     * @private\r\n     */\r\n    getBlockByNumber(blockNumber) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return this.provider.send('eth_getBlockByNumber', [\r\n                toHex(blockNumber),\r\n                false\r\n            ]);\r\n        });\r\n    }\r\n    /**\r\n     * Given a list of previous log events, finds the common block number from the\r\n     * logs that matches the block head.\r\n     *\r\n     * This can be used to identify which logs are part of a re-org.\r\n     *\r\n     * Returns 1 less than the oldest log's block number if no common ancestor was found.\r\n     *\r\n     * @private\r\n     */\r\n    getCommonAncestor(isCancelled, previousLogs) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            // Iterate from the most recent head backwards in order to find the first\r\n            // block that was part of a re-org.\r\n            let blockHead = yield this.getBlockByNumber(fromHex(previousLogs[previousLogs.length - 1].blockNumber));\r\n            throwIfCancelled(isCancelled);\r\n            for (let i = previousLogs.length - 1; i >= 0; i--) {\r\n                const oldLog = previousLogs[i];\r\n                // Ensure that updated blocks are fetched every time the log's block number\r\n                // changes.\r\n                if (oldLog.blockNumber !== blockHead.number) {\r\n                    blockHead = yield this.getBlockByNumber(fromHex(oldLog.blockNumber));\r\n                }\r\n                // Since logs are ordered in ascending order, the first log that matches\r\n                // the hash should be the largest logIndex.\r\n                if (oldLog.blockHash === blockHead.hash) {\r\n                    return {\r\n                        blockNumber: fromHex(oldLog.blockNumber),\r\n                        logIndex: fromHex(oldLog.logIndex)\r\n                    };\r\n                }\r\n            }\r\n            return {\r\n                blockNumber: Number.NEGATIVE_INFINITY,\r\n                logIndex: Number.NEGATIVE_INFINITY\r\n            };\r\n        });\r\n    }\r\n    /**\r\n     * Gets all `logs` events in the provided range. Note that the returned logs\r\n     * do not include removed logs.\r\n     *\r\n     * @private\r\n     */ getLogsInRange(filter, fromBlockInclusive, toBlockExclusive) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (fromBlockInclusive >= toBlockExclusive) {\r\n                return [];\r\n            }\r\n            const rangeFilter = Object.assign(Object.assign({}, filter), { fromBlock: toHex(fromBlockInclusive), toBlock: toHex(toBlockExclusive - 1) });\r\n            return this.provider.send('eth_getLogs', [rangeFilter]);\r\n        });\r\n    }\r\n}\r\nfunction toNewHeadsEvent(head) {\r\n    const result = Object.assign({}, head);\r\n    delete result.totalDifficulty;\r\n    delete result.transactions;\r\n    delete result.uncles;\r\n    return result;\r\n}\r\nfunction dedupeNewHeads(events) {\r\n    return dedupe(events, event => event.hash);\r\n}\r\nfunction dedupeLogs(events) {\r\n    return dedupe(events, event => `${event.blockHash}/${event.logIndex}`);\r\n}\r\nfunction dedupe(items, getKey) {\r\n    const keysSeen = new Set();\r\n    const result = [];\r\n    items.forEach(item => {\r\n        const key = getKey(item);\r\n        if (!keysSeen.has(key)) {\r\n            keysSeen.add(key);\r\n            result.push(item);\r\n        }\r\n    });\r\n    return result;\r\n}\r\nconst CANCELLED = new Error('Cancelled');\r\nfunction throwIfCancelled(isCancelled) {\r\n    if (isCancelled()) {\r\n        throw CANCELLED;\r\n    }\r\n}\n\nconst HEARTBEAT_INTERVAL = 30000;\r\nconst HEARTBEAT_WAIT_TIME = 10000;\r\nconst BACKFILL_TIMEOUT = 60000;\r\nconst BACKFILL_RETRIES = 5;\r\n/**\r\n * Subscriptions have a memory of recent events they have sent so that in the\r\n * event that they disconnect and need to backfill, they can detect re-orgs.\r\n * Keep a buffer that goes back at least these many blocks, the maximum amount\r\n * at which we might conceivably see a re-org.\r\n *\r\n * Note that while our buffer goes back this many blocks, it may contain more\r\n * than this many elements, since in the case of logs subscriptions more than\r\n * one event may be emitted for a block.\r\n */\r\nconst RETAINED_EVENT_BLOCK_COUNT = 10;\r\n/**\r\n * SDK's custom implementation fo the ethers.js's 'AlchemyWebSocketProvider'.\r\n *\r\n * Do not call this constructor directly. Instead, instantiate an instance of\r\n * {@link Alchemy} and call {@link Alchemy.config.getWebSocketProvider()}.\r\n *\r\n * @public\r\n */\r\nclass AlchemyWebSocketProvider extends WebSocketProvider {\r\n    /** @internal */\r\n    constructor(config, wsConstructor) {\r\n        var _a;\r\n        // Normalize the API Key to a string.\r\n        const apiKey = AlchemyProvider.getApiKey(config.apiKey);\r\n        // Generate our own connection info with the correct endpoint URLs.\r\n        const alchemyNetwork = AlchemyProvider.getAlchemyNetwork(config.network);\r\n        const connection = AlchemyProvider.getAlchemyConnectionInfo(alchemyNetwork, apiKey, 'wss');\r\n        const protocol = `alchemy-sdk-${VERSION}`;\r\n        // Use the provided config URL override if it exists, otherwise use the created one.\r\n        const ws = new SturdyWebSocket((_a = config.url) !== null && _a !== void 0 ? _a : connection.url, protocol, {\r\n            wsConstructor: wsConstructor !== null && wsConstructor !== void 0 ? wsConstructor : getWebsocketConstructor()\r\n        });\r\n        // Normalize the Alchemy named network input to the network names used by\r\n        // ethers. This allows the parent super constructor in JsonRpcProvider to\r\n        // correctly set the network.\r\n        const ethersNetwork = EthersNetwork[alchemyNetwork];\r\n        super(ws, ethersNetwork);\r\n        this._events = [];\r\n        // In the case of a WebSocket reconnection, all subscriptions are lost and we\r\n        // create new ones to replace them, but we want to create the illusion that\r\n        // the original subscriptions persist. Thus, maintain a mapping from the\r\n        // \"virtual\" subscription ids which are visible to the consumer to the\r\n        // \"physical\" subscription ids of the actual connections. This terminology is\r\n        // borrowed from virtual and physical memory, which has a similar mapping.\r\n        /** @internal */\r\n        this.virtualSubscriptionsById = new Map();\r\n        /** @internal */\r\n        this.virtualIdsByPhysicalId = new Map();\r\n        /**\r\n         * The underlying ethers {@link WebSocketProvider} already handles and emits\r\n         * messages. To allow backfilling, track all messages that are emitted.\r\n         *\r\n         * This is a field arrow function in order to preserve `this` context when\r\n         * passing the method as an event listener.\r\n         *\r\n         * @internal\r\n         */\r\n        this.handleMessage = (event) => {\r\n            const message = JSON.parse(event.data);\r\n            if (!isSubscriptionEvent(message)) {\r\n                return;\r\n            }\r\n            const physicalId = message.params.subscription;\r\n            const virtualId = this.virtualIdsByPhysicalId.get(physicalId);\r\n            if (!virtualId) {\r\n                return;\r\n            }\r\n            const subscription = this.virtualSubscriptionsById.get(virtualId);\r\n            if (subscription.method !== 'eth_subscribe') {\r\n                return;\r\n            }\r\n            switch (subscription.params[0]) {\r\n                case 'newHeads': {\r\n                    const newHeadsSubscription = subscription;\r\n                    const newHeadsMessage = message;\r\n                    const { isBackfilling, backfillBuffer } = newHeadsSubscription;\r\n                    const { result } = newHeadsMessage.params;\r\n                    if (isBackfilling) {\r\n                        addToNewHeadsEventsBuffer(backfillBuffer, result);\r\n                    }\r\n                    else if (physicalId !== virtualId) {\r\n                        // In the case of a re-opened subscription, ethers will not emit the\r\n                        // event, so the SDK has to.\r\n                        this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);\r\n                    }\r\n                    else {\r\n                        // Ethers subscription mapping will emit the event, just store it.\r\n                        this.rememberEvent(virtualId, result, getNewHeadsBlockNumber);\r\n                    }\r\n                    break;\r\n                }\r\n                case 'logs': {\r\n                    const logsSubscription = subscription;\r\n                    const logsMessage = message;\r\n                    const { isBackfilling, backfillBuffer } = logsSubscription;\r\n                    const { result } = logsMessage.params;\r\n                    if (isBackfilling) {\r\n                        addToLogsEventsBuffer(backfillBuffer, result);\r\n                    }\r\n                    else if (virtualId !== physicalId) {\r\n                        this.emitAndRememberEvent(virtualId, result, getLogsBlockNumber);\r\n                    }\r\n                    else {\r\n                        this.rememberEvent(virtualId, result, getLogsBlockNumber);\r\n                    }\r\n                    break;\r\n                }\r\n                default:\r\n                    if (physicalId !== virtualId) {\r\n                        // In the case of a re-opened subscription, ethers will not emit the\r\n                        // event, so the SDK has to.\r\n                        const { result } = message.params;\r\n                        this.emitEvent(virtualId, result);\r\n                    }\r\n            }\r\n        };\r\n        /**\r\n         * When the websocket connection reopens:\r\n         *\r\n         * 1. Resubscribe to all existing subscriptions and start backfilling\r\n         * 2. Restart heart beat.\r\n         *\r\n         * This is a field arrow function in order to preserve `this` context when\r\n         * passing the method as an event listener.\r\n         *\r\n         * @internal\r\n         */\r\n        this.handleReopen = () => {\r\n            this.virtualIdsByPhysicalId.clear();\r\n            const { cancel, isCancelled } = makeCancelToken();\r\n            this.cancelBackfill = cancel;\r\n            for (const subscription of this.virtualSubscriptionsById.values()) {\r\n                void (() => __awaiter(this, void 0, void 0, function* () {\r\n                    try {\r\n                        yield this.resubscribeAndBackfill(isCancelled, subscription);\r\n                    }\r\n                    catch (error) {\r\n                        if (!isCancelled()) {\r\n                            console.error(`Error while backfilling \"${subscription.params[0]}\" subscription. Some events may be missing.`, error);\r\n                        }\r\n                    }\r\n                }))();\r\n            }\r\n            this.startHeartbeat();\r\n        };\r\n        /**\r\n         * Cancels the heartbeat and any pending backfills being performed. This is\r\n         * called when the websocket connection goes down or is disconnected.\r\n         *\r\n         * This is a field arrow function in order to preserve `this` context when\r\n         * passing the method as an event listener.\r\n         *\r\n         * @internal\r\n         */\r\n        this.stopHeartbeatAndBackfill = () => {\r\n            if (this.heartbeatIntervalId != null) {\r\n                clearInterval(this.heartbeatIntervalId);\r\n                this.heartbeatIntervalId = undefined;\r\n            }\r\n            this.cancelBackfill();\r\n        };\r\n        this.apiKey = apiKey;\r\n        // Start heartbeat and backfiller for the websocket connection.\r\n        this.backfiller = new WebsocketBackfiller(this);\r\n        this.addSocketListeners();\r\n        this.startHeartbeat();\r\n        this.cancelBackfill = noop;\r\n    }\r\n    /**\r\n     * Overrides the `BaseProvider.getNetwork` method as implemented by ethers.js.\r\n     *\r\n     * This override allows the SDK to set the provider's network to values not\r\n     * yet supported by ethers.js.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */\r\n    static getNetwork(network) {\r\n        if (typeof network === 'string' && network in CustomNetworks) {\r\n            return CustomNetworks[network];\r\n        }\r\n        // Call the standard ethers.js getNetwork method for other networks.\r\n        return getNetwork(network);\r\n    }\r\n    /**\r\n     * Overridden implementation of ethers that includes Alchemy based subscriptions.\r\n     *\r\n     * @param eventName Event to subscribe to\r\n     * @param listener The listener function to call when the event is triggered.\r\n     * @override\r\n     * @public\r\n     */\r\n    // TODO: Override `Listener` type to get type autocompletions.\r\n    on(eventName, listener) {\r\n        return this._addEventListener(eventName, listener, false);\r\n    }\r\n    /**\r\n     * Overridden implementation of ethers that includes Alchemy based\r\n     * subscriptions. Adds a listener to the triggered for only the next\r\n     * {@link eventName} event, after which it will be removed.\r\n     *\r\n     * @param eventName Event to subscribe to\r\n     * @param listener The listener function to call when the event is triggered.\r\n     * @override\r\n     * @public\r\n     */\r\n    // TODO: Override `Listener` type to get type autocompletions.\r\n    once(eventName, listener) {\r\n        return this._addEventListener(eventName, listener, true);\r\n    }\r\n    /**\r\n     * Removes the provided {@link listener} for the {@link eventName} event. If no\r\n     * listener is provided, all listeners for the event will be removed.\r\n     *\r\n     * @param eventName Event to unlisten to.\r\n     * @param listener The listener function to remove.\r\n     * @override\r\n     * @public\r\n     */\r\n    off(eventName, listener) {\r\n        if (isAlchemyEvent(eventName)) {\r\n            return this._off(eventName, listener);\r\n        }\r\n        else {\r\n            return super.off(eventName, listener);\r\n        }\r\n    }\r\n    /**\r\n     * Remove all listeners for the provided {@link eventName} event. If no event\r\n     * is provided, all events and their listeners are removed.\r\n     *\r\n     * @param eventName The event to remove all listeners for.\r\n     * @override\r\n     * @public\r\n     */\r\n    removeAllListeners(eventName) {\r\n        if (eventName !== undefined && isAlchemyEvent(eventName)) {\r\n            return this._removeAllListeners(eventName);\r\n        }\r\n        else {\r\n            return super.removeAllListeners(eventName);\r\n        }\r\n    }\r\n    /**\r\n     * Returns the number of listeners for the provided {@link eventName} event. If\r\n     * no event is provided, the total number of listeners for all events is returned.\r\n     *\r\n     * @param eventName The event to get the number of listeners for.\r\n     * @public\r\n     * @override\r\n     */\r\n    listenerCount(eventName) {\r\n        if (eventName !== undefined && isAlchemyEvent(eventName)) {\r\n            return this._listenerCount(eventName);\r\n        }\r\n        else {\r\n            return super.listenerCount(eventName);\r\n        }\r\n    }\r\n    /**\r\n     * Returns an array of listeners for the provided {@link eventName} event. If\r\n     * no event is provided, all listeners will be included.\r\n     *\r\n     * @param eventName The event to get the listeners for.\r\n     * @public\r\n     * @override\r\n     */\r\n    listeners(eventName) {\r\n        if (eventName !== undefined && isAlchemyEvent(eventName)) {\r\n            return this._listeners(eventName);\r\n        }\r\n        else {\r\n            return super.listeners(eventName);\r\n        }\r\n    }\r\n    /**\r\n     * Overrides the method in `BaseProvider` in order to properly format the\r\n     * Alchemy subscription events.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */\r\n    _addEventListener(eventName, listener, once) {\r\n        if (isAlchemyEvent(eventName)) {\r\n            verifyAlchemyEventName(eventName);\r\n            const event = new EthersEvent(getAlchemyEventTag(eventName), listener, once);\r\n            this._events.push(event);\r\n            this._startEvent(event);\r\n            return this;\r\n        }\r\n        else {\r\n            return super._addEventListener(eventName, listener, once);\r\n        }\r\n    }\r\n    /**\r\n     * Overrides the `_startEvent()` method in ethers.js's\r\n     * {@link WebSocketProvider} to include additional alchemy methods.\r\n     *\r\n     * @param event\r\n     * @override\r\n     * @internal\r\n     */\r\n    _startEvent(event) {\r\n        // Check if the event type is a custom Alchemy subscription.\r\n        const customLogicTypes = [...ALCHEMY_EVENT_TYPES, 'block', 'filter'];\r\n        if (customLogicTypes.includes(event.type)) {\r\n            this.customStartEvent(event);\r\n        }\r\n        else {\r\n            super._startEvent(event);\r\n        }\r\n    }\r\n    /**\r\n     * Overridden from ethers.js's {@link WebSocketProvider}\r\n     *\r\n     * Modified in order to add mappings for backfilling.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */\r\n    _subscribe(tag, param, processFunc, event) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let subIdPromise = this._subIds[tag];\r\n            // BEGIN MODIFIED CODE\r\n            const startingBlockNumber = yield this.getBlockNumber();\r\n            // END MODIFIED CODE\r\n            if (subIdPromise == null) {\r\n                subIdPromise = Promise.all(param).then(param => {\r\n                    return this.send('eth_subscribe', param);\r\n                });\r\n                this._subIds[tag] = subIdPromise;\r\n            }\r\n            const subId = yield subIdPromise;\r\n            // BEGIN MODIFIED CODE\r\n            const resolvedParams = yield Promise.all(param);\r\n            this.virtualSubscriptionsById.set(subId, {\r\n                event: event,\r\n                method: 'eth_subscribe',\r\n                params: resolvedParams,\r\n                startingBlockNumber,\r\n                virtualId: subId,\r\n                physicalId: subId,\r\n                sentEvents: [],\r\n                isBackfilling: false,\r\n                backfillBuffer: []\r\n            });\r\n            this.virtualIdsByPhysicalId.set(subId, subId);\r\n            // END MODIFIED CODE\r\n            this._subs[subId] = { tag, processFunc };\r\n        });\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */\r\n    emit(eventName, ...args) {\r\n        if (isAlchemyEvent(eventName)) {\r\n            let result = false;\r\n            const stopped = [];\r\n            // This line is the only modified line from the original method.\r\n            const eventTag = getAlchemyEventTag(eventName);\r\n            this._events = this._events.filter(event => {\r\n                if (event.tag !== eventTag) {\r\n                    return true;\r\n                }\r\n                setTimeout(() => {\r\n                    event.listener.apply(this, args);\r\n                }, 0);\r\n                result = true;\r\n                if (event.once) {\r\n                    stopped.push(event);\r\n                    return false;\r\n                }\r\n                return true;\r\n            });\r\n            stopped.forEach(event => {\r\n                this._stopEvent(event);\r\n            });\r\n            return result;\r\n        }\r\n        else {\r\n            return super.emit(eventName, ...args);\r\n        }\r\n    }\r\n    /** @internal */\r\n    sendBatch(parts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let nextId = 0;\r\n            const payload = parts.map(({ method, params }) => {\r\n                return {\r\n                    method,\r\n                    params,\r\n                    jsonrpc: '2.0',\r\n                    id: `alchemy-sdk:${nextId++}`\r\n                };\r\n            });\r\n            return this.sendBatchConcurrently(payload);\r\n        });\r\n    }\r\n    /** @override */\r\n    destroy() {\r\n        this.removeSocketListeners();\r\n        this.stopHeartbeatAndBackfill();\r\n        return super.destroy();\r\n    }\r\n    /**\r\n     * Overrides the ether's `isCommunityResource()` method. Returns true if the\r\n     * current api key is the default key.\r\n     *\r\n     * @override\r\n     */\r\n    isCommunityResource() {\r\n        return this.apiKey === DEFAULT_ALCHEMY_API_KEY;\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `WebSocketProvider._stopEvent()`.\r\n     *\r\n     * This method is copied over directly in order to support Alchemy's\r\n     * subscription type by allowing the provider to properly stop Alchemy's\r\n     * subscription events.\r\n     *\r\n     * @internal\r\n     */\r\n    _stopEvent(event) {\r\n        let tag = event.tag;\r\n        // START MODIFIED CODE\r\n        if (ALCHEMY_EVENT_TYPES.includes(event.type)) {\r\n            // There are remaining pending transaction listeners.\r\n            if (this._events.filter(e => ALCHEMY_EVENT_TYPES.includes(e.type)).length) {\r\n                return;\r\n            }\r\n            // END MODIFIED CODE\r\n        }\r\n        else if (event.type === 'tx') {\r\n            // There are remaining transaction event listeners\r\n            if (this._events.filter(e => e.type === 'tx').length) {\r\n                return;\r\n            }\r\n            tag = 'tx';\r\n        }\r\n        else if (this.listenerCount(event.event)) {\r\n            // There are remaining event listeners\r\n            return;\r\n        }\r\n        const subId = this._subIds[tag];\r\n        if (!subId) {\r\n            return;\r\n        }\r\n        delete this._subIds[tag];\r\n        void subId.then(subId => {\r\n            if (!this._subs[subId]) {\r\n                return;\r\n            }\r\n            delete this._subs[subId];\r\n            void this.send('eth_unsubscribe', [subId]);\r\n        });\r\n    }\r\n    /** @internal */\r\n    addSocketListeners() {\r\n        this._websocket.addEventListener('message', this.handleMessage);\r\n        this._websocket.addEventListener('reopen', this.handleReopen);\r\n        this._websocket.addEventListener('down', this.stopHeartbeatAndBackfill);\r\n    }\r\n    /** @internal */\r\n    removeSocketListeners() {\r\n        this._websocket.removeEventListener('message', this.handleMessage);\r\n        this._websocket.removeEventListener('reopen', this.handleReopen);\r\n        this._websocket.removeEventListener('down', this.stopHeartbeatAndBackfill);\r\n    }\r\n    /**\r\n     * Reopens the backfill based on\r\n     *\r\n     * @param isCancelled\r\n     * @param subscription\r\n     * @internal\r\n     */\r\n    resubscribeAndBackfill(isCancelled, subscription) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { virtualId, method, params, sentEvents, backfillBuffer, startingBlockNumber } = subscription;\r\n            subscription.isBackfilling = true;\r\n            backfillBuffer.length = 0;\r\n            try {\r\n                const physicalId = yield this.send(method, params);\r\n                throwIfCancelled(isCancelled);\r\n                subscription.physicalId = physicalId;\r\n                this.virtualIdsByPhysicalId.set(physicalId, virtualId);\r\n                switch (params[0]) {\r\n                    case 'newHeads': {\r\n                        const backfillEvents = yield withBackoffRetries(() => withTimeout(this.backfiller.getNewHeadsBackfill(isCancelled, sentEvents, startingBlockNumber), BACKFILL_TIMEOUT), BACKFILL_RETRIES, () => !isCancelled());\r\n                        throwIfCancelled(isCancelled);\r\n                        const events = dedupeNewHeads([...backfillEvents, ...backfillBuffer]);\r\n                        events.forEach(event => this.emitNewHeadsEvent(virtualId, event));\r\n                        break;\r\n                    }\r\n                    case 'logs': {\r\n                        const filter = params[1] || {};\r\n                        const backfillEvents = yield withBackoffRetries(() => withTimeout(this.backfiller.getLogsBackfill(isCancelled, filter, sentEvents, startingBlockNumber), BACKFILL_TIMEOUT), BACKFILL_RETRIES, () => !isCancelled());\r\n                        throwIfCancelled(isCancelled);\r\n                        const events = dedupeLogs([...backfillEvents, ...backfillBuffer]);\r\n                        events.forEach(event => this.emitLogsEvent(virtualId, event));\r\n                        break;\r\n                    }\r\n                    default:\r\n                        break;\r\n                }\r\n            }\r\n            finally {\r\n                subscription.isBackfilling = false;\r\n                backfillBuffer.length = 0;\r\n            }\r\n        });\r\n    }\r\n    /** @internal */\r\n    emitNewHeadsEvent(virtualId, result) {\r\n        this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);\r\n    }\r\n    /** @internal */\r\n    emitLogsEvent(virtualId, result) {\r\n        this.emitAndRememberEvent(virtualId, result, getLogsBlockNumber);\r\n    }\r\n    /**\r\n     * Emits an event to consumers, but also remembers it in its subscriptions's\r\n     * `sentEvents` buffer so that we can detect re-orgs if the connection drops\r\n     * and needs to be reconnected.\r\n     *\r\n     * @internal\r\n     */\r\n    emitAndRememberEvent(virtualId, result, getBlockNumber) {\r\n        this.rememberEvent(virtualId, result, getBlockNumber);\r\n        this.emitEvent(virtualId, result);\r\n    }\r\n    emitEvent(virtualId, result) {\r\n        const subscription = this.virtualSubscriptionsById.get(virtualId);\r\n        if (!subscription) {\r\n            return;\r\n        }\r\n        this.emitGenericEvent(subscription, result);\r\n    }\r\n    /** @internal */\r\n    rememberEvent(virtualId, result, getBlockNumber) {\r\n        const subscription = this.virtualSubscriptionsById.get(virtualId);\r\n        if (!subscription) {\r\n            return;\r\n        }\r\n        // Web3 modifies these event objects once we pass them on (changing hex\r\n        // numbers to numbers). We want the original event, so make a defensive\r\n        // copy.\r\n        addToPastEventsBuffer(subscription.sentEvents, Object.assign({}, result), getBlockNumber);\r\n    }\r\n    /** @internal */\r\n    emitGenericEvent(subscription, result) {\r\n        const emitFunction = this.emitProcessFn(subscription.event);\r\n        emitFunction(result);\r\n    }\r\n    /**\r\n     * Starts a heartbeat that pings the websocket server periodically to ensure\r\n     * that the connection stays open.\r\n     *\r\n     * @internal\r\n     */\r\n    startHeartbeat() {\r\n        if (this.heartbeatIntervalId != null) {\r\n            return;\r\n        }\r\n        this.heartbeatIntervalId = setInterval(() => __awaiter(this, void 0, void 0, function* () {\r\n            try {\r\n                yield withTimeout(this.send('net_version'), HEARTBEAT_WAIT_TIME);\r\n            }\r\n            catch (_a) {\r\n                this._websocket.reconnect();\r\n            }\r\n        }), HEARTBEAT_INTERVAL);\r\n    }\r\n    /**\r\n     * This method sends the batch concurrently as individual requests rather than\r\n     * as a batch, which was the original implementation. The original batch logic\r\n     * is preserved in this implementation in order for faster porting.\r\n     *\r\n     * @param payload\r\n     * @internal\r\n     */\r\n    // TODO(cleanup): Refactor and remove usages of `sendBatch()`.\r\n    // TODO(errors): Use allSettled() once we have more error handling.\r\n    sendBatchConcurrently(payload) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return Promise.all(payload.map(req => this.send(req.method, req.params)));\r\n        });\r\n    }\r\n    /** @internal */\r\n    customStartEvent(event) {\r\n        if (event.type === ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE) {\r\n            const { fromAddress, toAddress, hashesOnly } = event;\r\n            void this._subscribe(event.tag, [\r\n                AlchemySubscription.PENDING_TRANSACTIONS,\r\n                { fromAddress, toAddress, hashesOnly }\r\n            ], this.emitProcessFn(event), event);\r\n        }\r\n        else if (event.type === ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE) {\r\n            const { addresses, includeRemoved, hashesOnly } = event;\r\n            void this._subscribe(event.tag, [\r\n                AlchemySubscription.MINED_TRANSACTIONS,\r\n                { addresses, includeRemoved, hashesOnly }\r\n            ], this.emitProcessFn(event), event);\r\n        }\r\n        else if (event.type === 'block') {\r\n            void this._subscribe('block', ['newHeads'], this.emitProcessFn(event), event);\r\n        }\r\n        else if (event.type === 'filter') {\r\n            void this._subscribe(event.tag, ['logs', this._getFilter(event.filter)], this.emitProcessFn(event), event);\r\n        }\r\n    }\r\n    /** @internal */\r\n    emitProcessFn(event) {\r\n        switch (event.type) {\r\n            case ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE:\r\n                return result => this.emit({\r\n                    method: AlchemySubscription.PENDING_TRANSACTIONS,\r\n                    fromAddress: event.fromAddress,\r\n                    toAddress: event.toAddress,\r\n                    hashesOnly: event.hashesOnly\r\n                }, result);\r\n            case ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE:\r\n                return result => this.emit({\r\n                    method: AlchemySubscription.MINED_TRANSACTIONS,\r\n                    addresses: event.addresses,\r\n                    includeRemoved: event.includeRemoved,\r\n                    hashesOnly: event.hashesOnly\r\n                }, result);\r\n            case 'block':\r\n                return result => {\r\n                    const blockNumber = BigNumber.from(result.number).toNumber();\r\n                    this._emitted.block = blockNumber;\r\n                    this.emit('block', blockNumber);\r\n                };\r\n            case 'filter':\r\n                return result => {\r\n                    if (result.removed == null) {\r\n                        result.removed = false;\r\n                    }\r\n                    this.emit(event.filter, this.formatter.filterLog(result));\r\n                };\r\n            default:\r\n                throw new Error('Invalid event type to `emitProcessFn()`');\r\n        }\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider.off()`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @private\r\n     */\r\n    _off(eventName, listener) {\r\n        if (listener == null) {\r\n            return this.removeAllListeners(eventName);\r\n        }\r\n        const stopped = [];\r\n        let found = false;\r\n        const eventTag = getAlchemyEventTag(eventName);\r\n        this._events = this._events.filter(event => {\r\n            if (event.tag !== eventTag || event.listener != listener) {\r\n                return true;\r\n            }\r\n            if (found) {\r\n                return true;\r\n            }\r\n            found = true;\r\n            stopped.push(event);\r\n            return false;\r\n        });\r\n        stopped.forEach(event => {\r\n            this._stopEvent(event);\r\n        });\r\n        return this;\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider.removeAllListeners()`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @private\r\n     */\r\n    _removeAllListeners(eventName) {\r\n        let stopped = [];\r\n        if (eventName == null) {\r\n            stopped = this._events;\r\n            this._events = [];\r\n        }\r\n        else {\r\n            const eventTag = getAlchemyEventTag(eventName);\r\n            this._events = this._events.filter(event => {\r\n                if (event.tag !== eventTag) {\r\n                    return true;\r\n                }\r\n                stopped.push(event);\r\n                return false;\r\n            });\r\n        }\r\n        stopped.forEach(event => {\r\n            this._stopEvent(event);\r\n        });\r\n        return this;\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider.listenerCount()`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @private\r\n     */\r\n    _listenerCount(eventName) {\r\n        if (!eventName) {\r\n            return this._events.length;\r\n        }\r\n        const eventTag = getAlchemyEventTag(eventName);\r\n        return this._events.filter(event => {\r\n            return event.tag === eventTag;\r\n        }).length;\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider.listeners()`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @private\r\n     */\r\n    _listeners(eventName) {\r\n        if (eventName == null) {\r\n            return this._events.map(event => event.listener);\r\n        }\r\n        const eventTag = getAlchemyEventTag(eventName);\r\n        return this._events\r\n            .filter(event => event.tag === eventTag)\r\n            .map(event => event.listener);\r\n    }\r\n}\r\nfunction getWebsocketConstructor() {\r\n    return isNodeEnvironment() ? require('websocket').w3cwebsocket : WebSocket;\r\n}\r\nfunction isNodeEnvironment() {\r\n    return (typeof process !== 'undefined' &&\r\n        process != null &&\r\n        process.versions != null &&\r\n        process.versions.node != null);\r\n}\r\n// TODO(cleanup): Use class variable rather than passing `isCancelled` everywhere.\r\nfunction makeCancelToken() {\r\n    let cancelled = false;\r\n    return { cancel: () => (cancelled = true), isCancelled: () => cancelled };\r\n}\r\n// TODO(cleanup): replace with SDK's backoff implementation\r\nconst MIN_RETRY_DELAY = 1000;\r\nconst RETRY_BACKOFF_FACTOR = 2;\r\nconst MAX_RETRY_DELAY = 30000;\r\nfunction withBackoffRetries(f, retryCount, shouldRetry = () => true) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        let nextWaitTime = 0;\r\n        let i = 0;\r\n        while (true) {\r\n            try {\r\n                return yield f();\r\n            }\r\n            catch (error) {\r\n                i++;\r\n                if (i >= retryCount || !shouldRetry(error)) {\r\n                    throw error;\r\n                }\r\n                yield delay(nextWaitTime);\r\n                if (!shouldRetry(error)) {\r\n                    throw error;\r\n                }\r\n                nextWaitTime =\r\n                    nextWaitTime === 0\r\n                        ? MIN_RETRY_DELAY\r\n                        : Math.min(MAX_RETRY_DELAY, RETRY_BACKOFF_FACTOR * nextWaitTime);\r\n            }\r\n        }\r\n    });\r\n}\r\nfunction delay(ms) {\r\n    return new Promise(resolve => setTimeout(resolve, ms));\r\n}\r\nfunction withTimeout(promise, ms) {\r\n    return Promise.race([\r\n        promise,\r\n        new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), ms))\r\n    ]);\r\n}\r\nfunction getNewHeadsBlockNumber(event) {\r\n    return fromHex(event.number);\r\n}\r\nfunction getLogsBlockNumber(event) {\r\n    return fromHex(event.blockNumber);\r\n}\r\nfunction isResponse(message) {\r\n    return (Array.isArray(message) ||\r\n        (message.jsonrpc === '2.0' && message.id !== undefined));\r\n}\r\nfunction isSubscriptionEvent(message) {\r\n    return !isResponse(message);\r\n}\r\nfunction addToNewHeadsEventsBuffer(pastEvents, event) {\r\n    addToPastEventsBuffer(pastEvents, event, getNewHeadsBlockNumber);\r\n}\r\nfunction addToLogsEventsBuffer(pastEvents, event) {\r\n    addToPastEventsBuffer(pastEvents, event, getLogsBlockNumber);\r\n}\r\n/**\r\n * Adds a new event to an array of events, evicting any events which are so old\r\n * that they will no longer feasibly be part of a reorg.\r\n */\r\nfunction addToPastEventsBuffer(pastEvents, event, getBlockNumber) {\r\n    const currentBlockNumber = getBlockNumber(event);\r\n    // Find first index of an event recent enough to retain, then drop everything\r\n    // at a lower index.\r\n    const firstGoodIndex = pastEvents.findIndex(e => getBlockNumber(e) > currentBlockNumber - RETAINED_EVENT_BLOCK_COUNT);\r\n    if (firstGoodIndex === -1) {\r\n        pastEvents.length = 0;\r\n    }\r\n    else {\r\n        pastEvents.splice(0, firstGoodIndex);\r\n    }\r\n    pastEvents.push(event);\r\n}\n\nexport { AlchemyWebSocketProvider };\n//# sourceMappingURL=alchemy-websocket-provider-35c345f7.js.map\n","var naiveFallback = function () {\n\tif (typeof self === \"object\" && self) return self;\n\tif (typeof window === \"object\" && window) return window;\n\tthrow new Error(\"Unable to resolve global `this`\");\n};\n\nmodule.exports = (function () {\n\tif (this) return this;\n\n\t// Unexpected strict mode (may happen if e.g. bundled into ESM module)\n\n\t// Fallback to standard globalThis if available\n\tif (typeof globalThis === \"object\" && globalThis) return globalThis;\n\n\t// Thanks @mathiasbynens -> https://mathiasbynens.be/notes/globalthis\n\t// In all ES5+ engines global object inherits from Object.prototype\n\t// (if you approached one that doesn't please report)\n\ttry {\n\t\tObject.defineProperty(Object.prototype, \"__global__\", {\n\t\t\tget: function () { return this; },\n\t\t\tconfigurable: true\n\t\t});\n\t} catch (error) {\n\t\t// Unfortunate case of updates to Object.prototype being restricted\n\t\t// via preventExtensions, seal or freeze\n\t\treturn naiveFallback();\n\t}\n\ttry {\n\t\t// Safari case (window.__global__ works, but __global__ does not)\n\t\tif (!__global__) return naiveFallback();\n\t\treturn __global__;\n\t} finally {\n\t\tdelete Object.prototype.__global__;\n\t}\n})();\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SHOULD_RECONNECT_FALSE_MESSAGE = \"Provided shouldReconnect() returned false. Closing permanently.\";\nvar SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE = \"Provided shouldReconnect() resolved to false. Closing permanently.\";\nvar SturdyWebSocket = /** @class */ (function () {\n    function SturdyWebSocket(url, protocolsOrOptions, options) {\n        if (options === void 0) { options = {}; }\n        this.url = url;\n        this.onclose = null;\n        this.onerror = null;\n        this.onmessage = null;\n        this.onopen = null;\n        this.ondown = null;\n        this.onreopen = null;\n        this.CONNECTING = SturdyWebSocket.CONNECTING;\n        this.OPEN = SturdyWebSocket.OPEN;\n        this.CLOSING = SturdyWebSocket.CLOSING;\n        this.CLOSED = SturdyWebSocket.CLOSED;\n        this.hasBeenOpened = false;\n        this.isClosed = false;\n        this.messageBuffer = [];\n        this.nextRetryTime = 0;\n        this.reconnectCount = 0;\n        this.lastKnownExtensions = \"\";\n        this.lastKnownProtocol = \"\";\n        this.listeners = {};\n        if (protocolsOrOptions == null ||\n            typeof protocolsOrOptions === \"string\" ||\n            Array.isArray(protocolsOrOptions)) {\n            this.protocols = protocolsOrOptions;\n        }\n        else {\n            options = protocolsOrOptions;\n        }\n        this.options = applyDefaultOptions(options);\n        if (!this.options.wsConstructor) {\n            if (typeof WebSocket !== \"undefined\") {\n                this.options.wsConstructor = WebSocket;\n            }\n            else {\n                throw new Error(\"WebSocket not present in global scope and no \" +\n                    \"wsConstructor option was provided.\");\n            }\n        }\n        this.openNewWebSocket();\n    }\n    Object.defineProperty(SturdyWebSocket.prototype, \"binaryType\", {\n        get: function () {\n            return this.binaryTypeInternal || \"blob\";\n        },\n        set: function (binaryType) {\n            this.binaryTypeInternal = binaryType;\n            if (this.ws) {\n                this.ws.binaryType = binaryType;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SturdyWebSocket.prototype, \"bufferedAmount\", {\n        get: function () {\n            var sum = this.ws ? this.ws.bufferedAmount : 0;\n            var hasUnknownAmount = false;\n            this.messageBuffer.forEach(function (data) {\n                var byteLength = getDataByteLength(data);\n                if (byteLength != null) {\n                    sum += byteLength;\n                }\n                else {\n                    hasUnknownAmount = true;\n                }\n            });\n            if (hasUnknownAmount) {\n                this.debugLog(\"Some buffered data had unknown length. bufferedAmount()\" +\n                    \" return value may be below the correct amount.\");\n            }\n            return sum;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SturdyWebSocket.prototype, \"extensions\", {\n        get: function () {\n            return this.ws ? this.ws.extensions : this.lastKnownExtensions;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SturdyWebSocket.prototype, \"protocol\", {\n        get: function () {\n            return this.ws ? this.ws.protocol : this.lastKnownProtocol;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SturdyWebSocket.prototype, \"readyState\", {\n        get: function () {\n            return this.isClosed ? SturdyWebSocket.CLOSED : SturdyWebSocket.OPEN;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    SturdyWebSocket.prototype.close = function (code, reason) {\n        this.disposeSocket(code, reason);\n        this.shutdown();\n        this.debugLog(\"WebSocket permanently closed by client.\");\n    };\n    SturdyWebSocket.prototype.send = function (data) {\n        if (this.isClosed) {\n            throw new Error(\"WebSocket is already in CLOSING or CLOSED state.\");\n        }\n        else if (this.ws && this.ws.readyState === this.OPEN) {\n            this.ws.send(data);\n        }\n        else {\n            this.messageBuffer.push(data);\n        }\n    };\n    SturdyWebSocket.prototype.reconnect = function () {\n        if (this.isClosed) {\n            throw new Error(\"Cannot call reconnect() on socket which is permanently closed.\");\n        }\n        this.disposeSocket(1000, \"Client requested reconnect.\");\n        this.handleClose(undefined);\n    };\n    SturdyWebSocket.prototype.addEventListener = function (type, listener) {\n        if (!this.listeners[type]) {\n            this.listeners[type] = [];\n        }\n        this.listeners[type].push(listener);\n    };\n    SturdyWebSocket.prototype.dispatchEvent = function (event) {\n        return this.dispatchEventOfType(event.type, event);\n    };\n    SturdyWebSocket.prototype.removeEventListener = function (type, listener) {\n        if (this.listeners[type]) {\n            this.listeners[type] = this.listeners[type].filter(function (l) { return l !== listener; });\n        }\n    };\n    SturdyWebSocket.prototype.openNewWebSocket = function () {\n        var _this = this;\n        if (this.isClosed) {\n            return;\n        }\n        var _a = this.options, connectTimeout = _a.connectTimeout, wsConstructor = _a.wsConstructor;\n        this.debugLog(\"Opening new WebSocket to \" + this.url + \".\");\n        var ws = new wsConstructor(this.url, this.protocols);\n        ws.onclose = function (event) { return _this.handleClose(event); };\n        ws.onerror = function (event) { return _this.handleError(event); };\n        ws.onmessage = function (event) { return _this.handleMessage(event); };\n        ws.onopen = function (event) { return _this.handleOpen(event); };\n        this.connectTimeoutId = setTimeout(function () {\n            // If this is running, we still haven't opened the websocket.\n            // Kill it so we can try again.\n            _this.clearConnectTimeout();\n            _this.disposeSocket();\n            _this.handleClose(undefined);\n        }, connectTimeout);\n        this.ws = ws;\n    };\n    SturdyWebSocket.prototype.handleOpen = function (event) {\n        var _this = this;\n        if (!this.ws || this.isClosed) {\n            return;\n        }\n        var allClearResetTime = this.options.allClearResetTime;\n        this.debugLog(\"WebSocket opened.\");\n        if (this.binaryTypeInternal != null) {\n            this.ws.binaryType = this.binaryTypeInternal;\n        }\n        else {\n            this.binaryTypeInternal = this.ws.binaryType;\n        }\n        this.clearConnectTimeout();\n        if (this.hasBeenOpened) {\n            this.dispatchEventOfType(\"reopen\", event);\n        }\n        else {\n            this.dispatchEventOfType(\"open\", event);\n            this.hasBeenOpened = true;\n        }\n        this.messageBuffer.forEach(function (message) { return _this.send(message); });\n        this.messageBuffer = [];\n        this.allClearTimeoutId = setTimeout(function () {\n            _this.clearAllClearTimeout();\n            _this.nextRetryTime = 0;\n            _this.reconnectCount = 0;\n            var openTime = (allClearResetTime / 1000) | 0;\n            _this.debugLog(\"WebSocket remained open for \" + openTime + \" seconds. Resetting\" +\n                \" retry time and count.\");\n        }, allClearResetTime);\n    };\n    SturdyWebSocket.prototype.handleMessage = function (event) {\n        if (this.isClosed) {\n            return;\n        }\n        this.dispatchEventOfType(\"message\", event);\n    };\n    SturdyWebSocket.prototype.handleClose = function (event) {\n        var _this = this;\n        if (this.isClosed) {\n            return;\n        }\n        var _a = this.options, maxReconnectAttempts = _a.maxReconnectAttempts, shouldReconnect = _a.shouldReconnect;\n        this.clearConnectTimeout();\n        this.clearAllClearTimeout();\n        if (this.ws) {\n            this.lastKnownExtensions = this.ws.extensions;\n            this.lastKnownProtocol = this.ws.protocol;\n            this.disposeSocket();\n        }\n        this.dispatchEventOfType(\"down\", event);\n        if (this.reconnectCount >= maxReconnectAttempts) {\n            this.stopReconnecting(event, this.getTooManyFailedReconnectsMessage());\n            return;\n        }\n        var willReconnect = !event || shouldReconnect(event);\n        if (typeof willReconnect === \"boolean\") {\n            this.handleWillReconnect(willReconnect, event, SHOULD_RECONNECT_FALSE_MESSAGE);\n        }\n        else {\n            willReconnect.then(function (willReconnectResolved) {\n                if (_this.isClosed) {\n                    return;\n                }\n                _this.handleWillReconnect(willReconnectResolved, event, SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE);\n            });\n        }\n    };\n    SturdyWebSocket.prototype.handleError = function (event) {\n        this.dispatchEventOfType(\"error\", event);\n        this.debugLog(\"WebSocket encountered an error.\");\n    };\n    SturdyWebSocket.prototype.handleWillReconnect = function (willReconnect, event, denialReason) {\n        if (willReconnect) {\n            this.reestablishConnection();\n        }\n        else {\n            this.stopReconnecting(event, denialReason);\n        }\n    };\n    SturdyWebSocket.prototype.reestablishConnection = function () {\n        var _this = this;\n        var _a = this.options, minReconnectDelay = _a.minReconnectDelay, maxReconnectDelay = _a.maxReconnectDelay, reconnectBackoffFactor = _a.reconnectBackoffFactor;\n        this.reconnectCount++;\n        var retryTime = this.nextRetryTime;\n        this.nextRetryTime = Math.max(minReconnectDelay, Math.min(this.nextRetryTime * reconnectBackoffFactor, maxReconnectDelay));\n        setTimeout(function () { return _this.openNewWebSocket(); }, retryTime);\n        var retryTimeSeconds = (retryTime / 1000) | 0;\n        this.debugLog(\"WebSocket was closed. Re-opening in \" + retryTimeSeconds + \" seconds.\");\n    };\n    SturdyWebSocket.prototype.stopReconnecting = function (event, debugReason) {\n        this.debugLog(debugReason);\n        this.shutdown();\n        if (event) {\n            this.dispatchEventOfType(\"close\", event);\n        }\n    };\n    SturdyWebSocket.prototype.shutdown = function () {\n        this.isClosed = true;\n        this.clearAllTimeouts();\n        this.messageBuffer = [];\n        this.disposeSocket();\n    };\n    SturdyWebSocket.prototype.disposeSocket = function (closeCode, reason) {\n        if (!this.ws) {\n            return;\n        }\n        // Use noop handlers instead of null because some WebSocket\n        // implementations, such as the one from isomorphic-ws, raise a stink on\n        // unhandled events.\n        this.ws.onerror = noop;\n        this.ws.onclose = noop;\n        this.ws.onmessage = noop;\n        this.ws.onopen = noop;\n        this.ws.close(closeCode, reason);\n        this.ws = undefined;\n    };\n    SturdyWebSocket.prototype.clearAllTimeouts = function () {\n        this.clearConnectTimeout();\n        this.clearAllClearTimeout();\n    };\n    SturdyWebSocket.prototype.clearConnectTimeout = function () {\n        if (this.connectTimeoutId != null) {\n            clearTimeout(this.connectTimeoutId);\n            this.connectTimeoutId = undefined;\n        }\n    };\n    SturdyWebSocket.prototype.clearAllClearTimeout = function () {\n        if (this.allClearTimeoutId != null) {\n            clearTimeout(this.allClearTimeoutId);\n            this.allClearTimeoutId = undefined;\n        }\n    };\n    SturdyWebSocket.prototype.dispatchEventOfType = function (type, event) {\n        var _this = this;\n        switch (type) {\n            case \"close\":\n                if (this.onclose) {\n                    this.onclose(event);\n                }\n                break;\n            case \"error\":\n                if (this.onerror) {\n                    this.onerror(event);\n                }\n                break;\n            case \"message\":\n                if (this.onmessage) {\n                    this.onmessage(event);\n                }\n                break;\n            case \"open\":\n                if (this.onopen) {\n                    this.onopen(event);\n                }\n                break;\n            case \"down\":\n                if (this.ondown) {\n                    this.ondown(event);\n                }\n                break;\n            case \"reopen\":\n                if (this.onreopen) {\n                    this.onreopen(event);\n                }\n                break;\n        }\n        if (type in this.listeners) {\n            this.listeners[type]\n                .slice()\n                .forEach(function (listener) { return _this.callListener(listener, event); });\n        }\n        return !event || !event.defaultPrevented;\n    };\n    SturdyWebSocket.prototype.callListener = function (listener, event) {\n        if (typeof listener === \"function\") {\n            listener.call(this, event);\n        }\n        else {\n            listener.handleEvent.call(this, event);\n        }\n    };\n    SturdyWebSocket.prototype.debugLog = function (message) {\n        if (this.options.debug) {\n            // tslint:disable-next-line:no-console\n            console.log(message);\n        }\n    };\n    SturdyWebSocket.prototype.getTooManyFailedReconnectsMessage = function () {\n        var maxReconnectAttempts = this.options.maxReconnectAttempts;\n        return \"Failed to reconnect after \" + maxReconnectAttempts + \" \" + pluralize(\"attempt\", maxReconnectAttempts) + \". Closing permanently.\";\n    };\n    SturdyWebSocket.DEFAULT_OPTIONS = {\n        allClearResetTime: 5000,\n        connectTimeout: 5000,\n        debug: false,\n        minReconnectDelay: 1000,\n        maxReconnectDelay: 30000,\n        maxReconnectAttempts: Number.POSITIVE_INFINITY,\n        reconnectBackoffFactor: 1.5,\n        shouldReconnect: function () { return true; },\n        wsConstructor: undefined,\n    };\n    SturdyWebSocket.CONNECTING = 0;\n    SturdyWebSocket.OPEN = 1;\n    SturdyWebSocket.CLOSING = 2;\n    SturdyWebSocket.CLOSED = 3;\n    return SturdyWebSocket;\n}());\nexports.default = SturdyWebSocket;\nfunction applyDefaultOptions(options) {\n    var result = {};\n    Object.keys(SturdyWebSocket.DEFAULT_OPTIONS).forEach(function (key) {\n        var value = options[key];\n        result[key] =\n            value === undefined\n                ? SturdyWebSocket.DEFAULT_OPTIONS[key]\n                : value;\n    });\n    return result;\n}\nfunction getDataByteLength(data) {\n    if (typeof data === \"string\") {\n        // UTF-16 strings use two bytes per character.\n        return 2 * data.length;\n    }\n    else if (data instanceof ArrayBuffer) {\n        return data.byteLength;\n    }\n    else if (data instanceof Blob) {\n        return data.size;\n    }\n    else {\n        return undefined;\n    }\n}\nfunction pluralize(s, n) {\n    return n === 1 ? s : s + \"s\";\n}\nfunction noop() {\n    // Nothing.\n}\n//# sourceMappingURL=index.js.map","var _globalThis;\nif (typeof globalThis === 'object') {\n\t_globalThis = globalThis;\n} else {\n\ttry {\n\t\t_globalThis = require('es5-ext/global');\n\t} catch (error) {\n\t} finally {\n\t\tif (!_globalThis && typeof window !== 'undefined') { _globalThis = window; }\n\t\tif (!_globalThis) { throw new Error('Could not determine global this'); }\n\t}\n}\n\nvar NativeWebSocket = _globalThis.WebSocket || _globalThis.MozWebSocket;\nvar websocket_version = require('./version');\n\n\n/**\n * Expose a W3C WebSocket class with just one or two arguments.\n */\nfunction W3CWebSocket(uri, protocols) {\n\tvar native_instance;\n\n\tif (protocols) {\n\t\tnative_instance = new NativeWebSocket(uri, protocols);\n\t}\n\telse {\n\t\tnative_instance = new NativeWebSocket(uri);\n\t}\n\n\t/**\n\t * 'native_instance' is an instance of nativeWebSocket (the browser's WebSocket\n\t * class). Since it is an Object it will be returned as it is when creating an\n\t * instance of W3CWebSocket via 'new W3CWebSocket()'.\n\t *\n\t * ECMAScript 5: http://bclary.com/2004/11/07/#a-13.2.2\n\t */\n\treturn native_instance;\n}\nif (NativeWebSocket) {\n\t['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'].forEach(function(prop) {\n\t\tObject.defineProperty(W3CWebSocket, prop, {\n\t\t\tget: function() { return NativeWebSocket[prop]; }\n\t\t});\n\t});\n}\n\n/**\n * Module exports.\n */\nmodule.exports = {\n    'w3cwebsocket' : NativeWebSocket ? W3CWebSocket : null,\n    'version'      : websocket_version\n};\n","module.exports = require('../package.json').version;\n"],"names":["WS","WebSocket","Error","error","logger","throwError","errors","UNSUPPORTED_OPERATION","operation","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","NextId","WebSocketProvider","constructor","url","network","super","this","_pollingInterval","_wsReady","connection","detectNetwork","websocket","onopen","Object","keys","_requests","forEach","id","send","payload","onmessage","messageEvent","data","JSON","parse","String","request","undefined","callback","emit","action","response","provider","message","code","method","sub","_subs","params","subscription","processFunc","console","warn","fauxPoll","setInterval","unref","_websocket","_detectNetwork","pollingInterval","resetEventsBlock","blockNumber","poll","polling","rid","stringify","jsonrpc","defaultUrl","_subscribe","tag","param","subIdPromise","_subIds","all","subId","_startEvent","event","type","from","number","toNumber","_emitted","block","_getFilter","filter","removed","formatter","filterLog","emitReceipt","hash","getTransactionReceipt","receipt","_events","log","_stopEvent","length","listenerCount","destroy","readyState","CONNECTING","onerror","close","WebsocketBackfiller","maxBackfillBlocks","getNewHeadsBackfill","isCancelled","previousHeads","fromBlockNumber","_","throwIfCancelled","toBlockNumber","getBlockNumber","getHeadEventsInRange","Math","max","lastSeenBlockNumber","f","minBlockNumber","reorgHeads","getReorgHeads","intermediateHeads","getLogsBackfill","previousLogs","getLogsInRange","commonAncestor","getCommonAncestor","removedLogs","map","assign","fromBlockInclusive","Number","NEGATIVE_INFINITY","addedLogs","logIndex","setMaxBackfillBlock","newMax","blockNumberHex","toBlockExclusive","batchParts","i","push","t","sendBatch","toNewHeadsEvent","oldEvent","blockHead","getBlockByNumber","reverse","oldLog","blockHash","rangeFilter","fromBlock","toBlock","head","totalDifficulty","transactions","uncles","dedupe","items","getKey","keysSeen","Set","item","key","has","add","CANCELLED","AlchemyWebSocketProvider","config","wsConstructor","_a","apiKey","AlchemyProvider","getApiKey","alchemyNetwork","getAlchemyNetwork","getAlchemyConnectionInfo","protocol","V","process","versions","node","E","virtualSubscriptionsById","Map","virtualIdsByPhysicalId","handleMessage","Array","isArray","isResponse","isSubscriptionEvent","physicalId","virtualId","get","newHeadsSubscription","newHeadsMessage","isBackfilling","backfillBuffer","pastEvents","addToPastEventsBuffer","getNewHeadsBlockNumber","addToNewHeadsEventsBuffer","emitAndRememberEvent","rememberEvent","logsSubscription","logsMessage","getLogsBlockNumber","addToLogsEventsBuffer","emitEvent","handleReopen","clear","cancel","cancelled","makeCancelToken","cancelBackfill","values","resubscribeAndBackfill","startHeartbeat","stopHeartbeatAndBackfill","heartbeatIntervalId","clearInterval","backfiller","addSocketListeners","n","getNetwork","C","on","eventName","listener","_addEventListener","once","off","_off","removeAllListeners","_removeAllListeners","_listenerCount","listeners","_listeners","v","A","includes","customStartEvent","startingBlockNumber","resolvedParams","set","sentEvents","args","stopped","eventTag","setTimeout","parts","nextId","sendBatchConcurrently","removeSocketListeners","isCommunityResource","D","addEventListener","removeEventListener","backfillEvents","withBackoffRetries","withTimeout","events","emitNewHeadsEvent","dedupeLogs","emitLogsEvent","emitGenericEvent","emitProcessFn","emitFunction","reconnect","req","fromAddress","toAddress","hashesOnly","PENDING_TRANSACTIONS","addresses","includeRemoved","MINED_TRANSACTIONS","found","MIN_RETRY_DELAY","RETRY_BACKOFF_FACTOR","MAX_RETRY_DELAY","retryCount","shouldRetry","nextWaitTime","delay","min","ms","promise","race","currentBlockNumber","firstGoodIndex","findIndex","splice","naiveFallback","self","window","module","exports","globalThis","defineProperty","prototype","configurable","__global__","SturdyWebSocket","protocolsOrOptions","options","onclose","ondown","onreopen","OPEN","CLOSING","CLOSED","hasBeenOpened","isClosed","messageBuffer","nextRetryTime","reconnectCount","lastKnownExtensions","lastKnownProtocol","protocols","applyDefaultOptions","openNewWebSocket","binaryTypeInternal","binaryType","ws","enumerable","sum","bufferedAmount","hasUnknownAmount","byteLength","ArrayBuffer","Blob","size","getDataByteLength","debugLog","extensions","reason","disposeSocket","shutdown","handleClose","dispatchEvent","dispatchEventOfType","l","_this","connectTimeout","handleError","handleOpen","connectTimeoutId","clearConnectTimeout","allClearResetTime","allClearTimeoutId","clearAllClearTimeout","openTime","maxReconnectAttempts","shouldReconnect","stopReconnecting","getTooManyFailedReconnectsMessage","willReconnect","handleWillReconnect","willReconnectResolved","denialReason","reestablishConnection","minReconnectDelay","maxReconnectDelay","reconnectBackoffFactor","retryTime","retryTimeSeconds","debugReason","clearAllTimeouts","closeCode","noop","clearTimeout","slice","callListener","defaultPrevented","call","handleEvent","debug","s","DEFAULT_OPTIONS","POSITIVE_INFINITY","_globalThis","NativeWebSocket","MozWebSocket","websocket_version","W3CWebSocket","uri","prop"],"sourceRoot":""}