{"version":3,"file":"js/bundle.73d99417b7dd991d515d.min.js","mappings":"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","sources":["webpack:///../node_modules/@ethersproject/providers/lib.esm/ws.js","webpack:///../node_modules/@ethersproject/providers/lib.esm/websocket-provider.js","webpack:///../node_modules/alchemy-sdk/dist/esm/alchemy-websocket-provider-35c345f7.js","webpack:///../node_modules/es5-ext/global.js","webpack:///../node_modules/sturdy-websocket/dist/index.js","webpack:///../node_modules/websocket/lib/browser.js","webpack:///../node_modules/websocket/lib/version.js"],"sourcesContent":["\"use strict\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nlet WS = null;\ntry {\n    WS = WebSocket;\n    if (WS == null) {\n        throw new Error(\"inject please\");\n    }\n}\ncatch (error) {\n    const logger = new Logger(version);\n    WS = function () {\n        logger.throwError(\"WebSockets not supported in this environment\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"new WebSocket()\"\n        });\n    };\n}\n//export default WS;\n//module.exports = WS;\nexport { WS as WebSocket };\n//# sourceMappingURL=ws.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\nimport { WebSocket } from \"./ws\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n/**\n *  Notes:\n *\n *  This provider differs a bit from the polling providers. One main\n *  difference is how it handles consistency. The polling providers\n *  will stall responses to ensure a consistent state, while this\n *  WebSocket provider assumes the connected backend will manage this.\n *\n *  For example, if a polling provider emits an event which indicates\n *  the event occurred in blockhash XXX, a call to fetch that block by\n *  its hash XXX, if not present will retry until it is present. This\n *  can occur when querying a pool of nodes that are mildly out of sync\n *  with each other.\n */\nlet NextId = 1;\n// For more info about the Real-time Event API see:\n//   https://geth.ethereum.org/docs/rpc/pubsub\nexport class WebSocketProvider extends JsonRpcProvider {\n    constructor(url, network) {\n        // This will be added in the future; please open an issue to expedite\n        if (network === \"any\") {\n            logger.throwError(\"WebSocketProvider does not support 'any' network yet\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"network:any\"\n            });\n        }\n        if (typeof (url) === \"string\") {\n            super(url, network);\n        }\n        else {\n            super(\"_websocket\", network);\n        }\n        this._pollingInterval = -1;\n        this._wsReady = false;\n        if (typeof (url) === \"string\") {\n            defineReadOnly(this, \"_websocket\", new WebSocket(this.connection.url));\n        }\n        else {\n            defineReadOnly(this, \"_websocket\", url);\n        }\n        defineReadOnly(this, \"_requests\", {});\n        defineReadOnly(this, \"_subs\", {});\n        defineReadOnly(this, \"_subIds\", {});\n        defineReadOnly(this, \"_detectNetwork\", super.detectNetwork());\n        // Stall sending requests until the socket is open...\n        this.websocket.onopen = () => {\n            this._wsReady = true;\n            Object.keys(this._requests).forEach((id) => {\n                this.websocket.send(this._requests[id].payload);\n            });\n        };\n        this.websocket.onmessage = (messageEvent) => {\n            const data = messageEvent.data;\n            const result = JSON.parse(data);\n            if (result.id != null) {\n                const id = String(result.id);\n                const request = this._requests[id];\n                delete this._requests[id];\n                if (result.result !== undefined) {\n                    request.callback(null, result.result);\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        request: JSON.parse(request.payload),\n                        response: result.result,\n                        provider: this\n                    });\n                }\n                else {\n                    let error = null;\n                    if (result.error) {\n                        error = new Error(result.error.message || \"unknown error\");\n                        defineReadOnly(error, \"code\", result.error.code || null);\n                        defineReadOnly(error, \"response\", data);\n                    }\n                    else {\n                        error = new Error(\"unknown error\");\n                    }\n                    request.callback(error, undefined);\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        error: error,\n                        request: JSON.parse(request.payload),\n                        provider: this\n                    });\n                }\n            }\n            else if (result.method === \"eth_subscription\") {\n                // Subscription...\n                const sub = this._subs[result.params.subscription];\n                if (sub) {\n                    //this.emit.apply(this,                  );\n                    sub.processFunc(result.params.result);\n                }\n            }\n            else {\n                console.warn(\"this should not happen\");\n            }\n        };\n        // This Provider does not actually poll, but we want to trigger\n        // poll events for things that depend on them (like stalling for\n        // block and transaction lookups)\n        const fauxPoll = setInterval(() => {\n            this.emit(\"poll\");\n        }, 1000);\n        if (fauxPoll.unref) {\n            fauxPoll.unref();\n        }\n    }\n    // Cannot narrow the type of _websocket, as that is not backwards compatible\n    // so we add a getter and let the WebSocket be a public API.\n    get websocket() { return this._websocket; }\n    detectNetwork() {\n        return this._detectNetwork;\n    }\n    get pollingInterval() {\n        return 0;\n    }\n    resetEventsBlock(blockNumber) {\n        logger.throwError(\"cannot reset events block on WebSocketProvider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"resetEventBlock\"\n        });\n    }\n    set pollingInterval(value) {\n        logger.throwError(\"cannot set polling interval on WebSocketProvider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"setPollingInterval\"\n        });\n    }\n    poll() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return null;\n        });\n    }\n    set polling(value) {\n        if (!value) {\n            return;\n        }\n        logger.throwError(\"cannot set polling on WebSocketProvider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"setPolling\"\n        });\n    }\n    send(method, params) {\n        const rid = NextId++;\n        return new Promise((resolve, reject) => {\n            function callback(error, result) {\n                if (error) {\n                    return reject(error);\n                }\n                return resolve(result);\n            }\n            const payload = JSON.stringify({\n                method: method,\n                params: params,\n                id: rid,\n                jsonrpc: \"2.0\"\n            });\n            this.emit(\"debug\", {\n                action: \"request\",\n                request: JSON.parse(payload),\n                provider: this\n            });\n            this._requests[String(rid)] = { callback, payload };\n            if (this._wsReady) {\n                this.websocket.send(payload);\n            }\n        });\n    }\n    static defaultUrl() {\n        return \"ws:/\\/localhost:8546\";\n    }\n    _subscribe(tag, param, processFunc) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let subIdPromise = this._subIds[tag];\n            if (subIdPromise == null) {\n                subIdPromise = Promise.all(param).then((param) => {\n                    return this.send(\"eth_subscribe\", param);\n                });\n                this._subIds[tag] = subIdPromise;\n            }\n            const subId = yield subIdPromise;\n            this._subs[subId] = { tag, processFunc };\n        });\n    }\n    _startEvent(event) {\n        switch (event.type) {\n            case \"block\":\n                this._subscribe(\"block\", [\"newHeads\"], (result) => {\n                    const blockNumber = BigNumber.from(result.number).toNumber();\n                    this._emitted.block = blockNumber;\n                    this.emit(\"block\", blockNumber);\n                });\n                break;\n            case \"pending\":\n                this._subscribe(\"pending\", [\"newPendingTransactions\"], (result) => {\n                    this.emit(\"pending\", result);\n                });\n                break;\n            case \"filter\":\n                this._subscribe(event.tag, [\"logs\", this._getFilter(event.filter)], (result) => {\n                    if (result.removed == null) {\n                        result.removed = false;\n                    }\n                    this.emit(event.filter, this.formatter.filterLog(result));\n                });\n                break;\n            case \"tx\": {\n                const emitReceipt = (event) => {\n                    const hash = event.hash;\n                    this.getTransactionReceipt(hash).then((receipt) => {\n                        if (!receipt) {\n                            return;\n                        }\n                        this.emit(hash, receipt);\n                    });\n                };\n                // In case it is already mined\n                emitReceipt(event);\n                // To keep things simple, we start up a single newHeads subscription\n                // to keep an eye out for transactions we are watching for.\n                // Starting a subscription for an event (i.e. \"tx\") that is already\n                // running is (basically) a nop.\n                this._subscribe(\"tx\", [\"newHeads\"], (result) => {\n                    this._events.filter((e) => (e.type === \"tx\")).forEach(emitReceipt);\n                });\n                break;\n            }\n            // Nothing is needed\n            case \"debug\":\n            case \"poll\":\n            case \"willPoll\":\n            case \"didPoll\":\n            case \"error\":\n                break;\n            default:\n                console.log(\"unhandled:\", event);\n                break;\n        }\n    }\n    _stopEvent(event) {\n        let tag = event.tag;\n        if (event.type === \"tx\") {\n            // There are remaining transaction event listeners\n            if (this._events.filter((e) => (e.type === \"tx\")).length) {\n                return;\n            }\n            tag = \"tx\";\n        }\n        else if (this.listenerCount(event.event)) {\n            // There are remaining event listeners\n            return;\n        }\n        const subId = this._subIds[tag];\n        if (!subId) {\n            return;\n        }\n        delete this._subIds[tag];\n        subId.then((subId) => {\n            if (!this._subs[subId]) {\n                return;\n            }\n            delete this._subs[subId];\n            this.send(\"eth_unsubscribe\", [subId]);\n        });\n    }\n    destroy() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Wait until we have connected before trying to disconnect\n            if (this.websocket.readyState === WebSocket.CONNECTING) {\n                yield (new Promise((resolve) => {\n                    this.websocket.onopen = function () {\n                        resolve(true);\n                    };\n                    this.websocket.onerror = function () {\n                        resolve(false);\n                    };\n                }));\n            }\n            // Hangup\n            // See: https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes\n            this.websocket.close(1000);\n        });\n    }\n}\n//# sourceMappingURL=websocket-provider.js.map","import { _ as __awaiter, f as fromHex, t as toHex, n as noop, C as CustomNetworks, i as isAlchemyEvent, v as verifyAlchemyEventName, c as EthersEvent, d as getAlchemyEventTag, D as DEFAULT_ALCHEMY_API_KEY, A as ALCHEMY_EVENT_TYPES, e as ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE, h as AlchemySubscription, j as ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE, V as VERSION, E as EthersNetwork } from './index-02af91ae.js';\nimport SturdyWebSocket from 'sturdy-websocket';\nimport { BigNumber } from '@ethersproject/bignumber';\nimport { getNetwork } from '@ethersproject/networks';\nimport { WebSocketProvider } from '@ethersproject/providers';\nimport { AlchemyProvider } from './alchemy-provider-a776ca8a.js';\nimport './api/utils';\nimport 'axios';\nimport '@ethersproject/abstract-provider';\nimport '@ethersproject/wallet';\nimport '@ethersproject/contracts';\nimport '@ethersproject/web';\n\n/**\r\n * The maximum number of blocks to backfill. If more than this many blocks have\r\n * been missed, then we'll sadly miss data, but we want to make sure we don't\r\n * end up requesting thousands of blocks if somebody left their laptop closed for a week.\r\n */\r\nconst MAX_BACKFILL_BLOCKS = 120;\r\n/**\r\n * The WebsocketBackfiller fetches events that were sent since a provided block\r\n * number. This is used in the {@link AlchemyWebSocketProvider} to backfill\r\n * events that were transmitted while the websocket connection was down.\r\n *\r\n * The backfiller backfills two main eth_subscribe events: `logs` and `newHeads`.\r\n *\r\n * @internal\r\n */\r\nclass WebsocketBackfiller {\r\n    constructor(provider) {\r\n        this.provider = provider;\r\n        // TODO: Use HTTP provider to do backfill.\r\n        this.maxBackfillBlocks = MAX_BACKFILL_BLOCKS;\r\n    }\r\n    /**\r\n     * Runs backfill for `newHeads` events.\r\n     *\r\n     * @param isCancelled Whether the backfill request is cancelled.\r\n     * @param previousHeads Previous head requests that were sent.\r\n     * @param fromBlockNumber The block number to start backfilling from.\r\n     * @returns A list of `newHeads` events that were sent since the last backfill.\r\n     */\r\n    getNewHeadsBackfill(isCancelled, previousHeads, fromBlockNumber) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            throwIfCancelled(isCancelled);\r\n            const toBlockNumber = yield this.getBlockNumber();\r\n            throwIfCancelled(isCancelled);\r\n            // If there are no previous heads to fetch, return new heads since\r\n            // `fromBlockNumber`, or up to maxBackfillBlocks from the current head.\r\n            if (previousHeads.length === 0) {\r\n                return this.getHeadEventsInRange(Math.max(fromBlockNumber, toBlockNumber - this.maxBackfillBlocks) + 1, toBlockNumber + 1);\r\n            }\r\n            // If the last emitted event is too far back in the past, there's no need\r\n            // to backfill for reorgs. Just fetch the last `maxBackfillBlocks` worth of\r\n            // new heads.\r\n            const lastSeenBlockNumber = fromHex(previousHeads[previousHeads.length - 1].number);\r\n            const minBlockNumber = toBlockNumber - this.maxBackfillBlocks + 1;\r\n            if (lastSeenBlockNumber <= minBlockNumber) {\r\n                return this.getHeadEventsInRange(minBlockNumber, toBlockNumber + 1);\r\n            }\r\n            // To capture all `newHeads` events, return all head events from the last\r\n            // seen block number to current + any of the previous heads that were re-orged.\r\n            const reorgHeads = yield this.getReorgHeads(isCancelled, previousHeads);\r\n            throwIfCancelled(isCancelled);\r\n            const intermediateHeads = yield this.getHeadEventsInRange(lastSeenBlockNumber + 1, toBlockNumber + 1);\r\n            throwIfCancelled(isCancelled);\r\n            return [...reorgHeads, ...intermediateHeads];\r\n        });\r\n    }\r\n    /**\r\n     * Runs backfill for `logs` events.\r\n     *\r\n     * @param isCancelled Whether the backfill request is cancelled.\r\n     * @param filter The filter object that accompanies a logs subscription.\r\n     * @param previousLogs Previous log requests that were sent.\r\n     * @param fromBlockNumber The block number to start backfilling from.\r\n     */\r\n    getLogsBackfill(isCancelled, filter, previousLogs, fromBlockNumber) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            throwIfCancelled(isCancelled);\r\n            const toBlockNumber = yield this.getBlockNumber();\r\n            throwIfCancelled(isCancelled);\r\n            // If there are no previous logs to fetch, return new logs since\r\n            // `fromBlockNumber`, or up to `maxBackfillBlocks` from the current head.\r\n            if (previousLogs.length === 0) {\r\n                return this.getLogsInRange(filter, Math.max(fromBlockNumber, toBlockNumber - this.maxBackfillBlocks) + 1, toBlockNumber + 1);\r\n            }\r\n            // If the last emitted log is too far back in the past, there's no need\r\n            // to backfill for removed logs. Just fetch the last `maxBackfillBlocks`\r\n            // worth of logs.\r\n            const lastSeenBlockNumber = fromHex(previousLogs[previousLogs.length - 1].blockNumber);\r\n            const minBlockNumber = toBlockNumber - this.maxBackfillBlocks + 1;\r\n            if (lastSeenBlockNumber < minBlockNumber) {\r\n                return this.getLogsInRange(filter, minBlockNumber, toBlockNumber + 1);\r\n            }\r\n            // Return all log events that have happened along with log events that have\r\n            // been removed due to a chain reorg.\r\n            const commonAncestor = yield this.getCommonAncestor(isCancelled, previousLogs);\r\n            throwIfCancelled(isCancelled);\r\n            // All previous logs with a block number greater than the common ancestor\r\n            // were part of a re-org, so mark them as such.\r\n            const removedLogs = previousLogs\r\n                .filter(log => fromHex(log.blockNumber) > commonAncestor.blockNumber)\r\n                .map(log => (Object.assign(Object.assign({}, log), { removed: true })));\r\n            // If no common ancestor was found, start backfill from the oldest log's\r\n            // block number.\r\n            const fromBlockInclusive = commonAncestor.blockNumber === Number.NEGATIVE_INFINITY\r\n                ? fromHex(previousLogs[0].blockNumber)\r\n                : commonAncestor.blockNumber;\r\n            let addedLogs = yield this.getLogsInRange(filter, fromBlockInclusive, toBlockNumber + 1);\r\n            // De-dupe any logs that were already emitted.\r\n            addedLogs = addedLogs.filter(log => log &&\r\n                (fromHex(log.blockNumber) > commonAncestor.blockNumber ||\r\n                    fromHex(log.logIndex) > commonAncestor.logIndex));\r\n            throwIfCancelled(isCancelled);\r\n            return [...removedLogs, ...addedLogs];\r\n        });\r\n    }\r\n    /**\r\n     * Sets a new max backfill blocks. VISIBLE ONLY FOR TESTING.\r\n     *\r\n     * @internal\r\n     */\r\n    setMaxBackfillBlock(newMax) {\r\n        this.maxBackfillBlocks = newMax;\r\n    }\r\n    /**\r\n     * Gets the current block number as a number.\r\n     *\r\n     * @private\r\n     */\r\n    getBlockNumber() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const blockNumberHex = yield this.provider.send('eth_blockNumber');\r\n            return fromHex(blockNumberHex);\r\n        });\r\n    }\r\n    /**\r\n     * Gets all `newHead` events in the provided range. Note that the returned\r\n     * heads do not include re-orged heads. Use {@link getReorgHeads} to find heads\r\n     * that were part of a re-org.\r\n     *\r\n     * @private\r\n     */\r\n    getHeadEventsInRange(fromBlockInclusive, toBlockExclusive) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (fromBlockInclusive >= toBlockExclusive) {\r\n                return [];\r\n            }\r\n            const batchParts = [];\r\n            for (let i = fromBlockInclusive; i < toBlockExclusive; i++) {\r\n                batchParts.push({\r\n                    method: 'eth_getBlockByNumber',\r\n                    params: [toHex(i), false]\r\n                });\r\n            }\r\n            // TODO: handle errors\r\n            const blockHeads = yield this.provider.sendBatch(batchParts);\r\n            return blockHeads.map(toNewHeadsEvent);\r\n        });\r\n    }\r\n    /**\r\n     * Returns all heads that were part of a reorg event.\r\n     *\r\n     * @private\r\n     */\r\n    getReorgHeads(isCancelled, previousHeads) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const result = [];\r\n            // Iterate from the most recent head backwards in order to find the first\r\n            // block that was part of a re-org.\r\n            for (let i = previousHeads.length - 1; i >= 0; i--) {\r\n                const oldEvent = previousHeads[i];\r\n                const blockHead = yield this.getBlockByNumber(fromHex(oldEvent.number));\r\n                throwIfCancelled(isCancelled);\r\n                // If the hashes match, then current head in the iteration was not re-orged.\r\n                if (oldEvent.hash === blockHead.hash) {\r\n                    break;\r\n                }\r\n                result.push(toNewHeadsEvent(blockHead));\r\n            }\r\n            return result.reverse();\r\n        });\r\n    }\r\n    /**\r\n     * Simple wrapper around `eth_getBlockByNumber` that returns the complete\r\n     * block information for the provided block number.\r\n     *\r\n     * @private\r\n     */\r\n    getBlockByNumber(blockNumber) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return this.provider.send('eth_getBlockByNumber', [\r\n                toHex(blockNumber),\r\n                false\r\n            ]);\r\n        });\r\n    }\r\n    /**\r\n     * Given a list of previous log events, finds the common block number from the\r\n     * logs that matches the block head.\r\n     *\r\n     * This can be used to identify which logs are part of a re-org.\r\n     *\r\n     * Returns 1 less than the oldest log's block number if no common ancestor was found.\r\n     *\r\n     * @private\r\n     */\r\n    getCommonAncestor(isCancelled, previousLogs) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            // Iterate from the most recent head backwards in order to find the first\r\n            // block that was part of a re-org.\r\n            let blockHead = yield this.getBlockByNumber(fromHex(previousLogs[previousLogs.length - 1].blockNumber));\r\n            throwIfCancelled(isCancelled);\r\n            for (let i = previousLogs.length - 1; i >= 0; i--) {\r\n                const oldLog = previousLogs[i];\r\n                // Ensure that updated blocks are fetched every time the log's block number\r\n                // changes.\r\n                if (oldLog.blockNumber !== blockHead.number) {\r\n                    blockHead = yield this.getBlockByNumber(fromHex(oldLog.blockNumber));\r\n                }\r\n                // Since logs are ordered in ascending order, the first log that matches\r\n                // the hash should be the largest logIndex.\r\n                if (oldLog.blockHash === blockHead.hash) {\r\n                    return {\r\n                        blockNumber: fromHex(oldLog.blockNumber),\r\n                        logIndex: fromHex(oldLog.logIndex)\r\n                    };\r\n                }\r\n            }\r\n            return {\r\n                blockNumber: Number.NEGATIVE_INFINITY,\r\n                logIndex: Number.NEGATIVE_INFINITY\r\n            };\r\n        });\r\n    }\r\n    /**\r\n     * Gets all `logs` events in the provided range. Note that the returned logs\r\n     * do not include removed logs.\r\n     *\r\n     * @private\r\n     */ getLogsInRange(filter, fromBlockInclusive, toBlockExclusive) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (fromBlockInclusive >= toBlockExclusive) {\r\n                return [];\r\n            }\r\n            const rangeFilter = Object.assign(Object.assign({}, filter), { fromBlock: toHex(fromBlockInclusive), toBlock: toHex(toBlockExclusive - 1) });\r\n            return this.provider.send('eth_getLogs', [rangeFilter]);\r\n        });\r\n    }\r\n}\r\nfunction toNewHeadsEvent(head) {\r\n    const result = Object.assign({}, head);\r\n    delete result.totalDifficulty;\r\n    delete result.transactions;\r\n    delete result.uncles;\r\n    return result;\r\n}\r\nfunction dedupeNewHeads(events) {\r\n    return dedupe(events, event => event.hash);\r\n}\r\nfunction dedupeLogs(events) {\r\n    return dedupe(events, event => `${event.blockHash}/${event.logIndex}`);\r\n}\r\nfunction dedupe(items, getKey) {\r\n    const keysSeen = new Set();\r\n    const result = [];\r\n    items.forEach(item => {\r\n        const key = getKey(item);\r\n        if (!keysSeen.has(key)) {\r\n            keysSeen.add(key);\r\n            result.push(item);\r\n        }\r\n    });\r\n    return result;\r\n}\r\nconst CANCELLED = new Error('Cancelled');\r\nfunction throwIfCancelled(isCancelled) {\r\n    if (isCancelled()) {\r\n        throw CANCELLED;\r\n    }\r\n}\n\nconst HEARTBEAT_INTERVAL = 30000;\r\nconst HEARTBEAT_WAIT_TIME = 10000;\r\nconst BACKFILL_TIMEOUT = 60000;\r\nconst BACKFILL_RETRIES = 5;\r\n/**\r\n * Subscriptions have a memory of recent events they have sent so that in the\r\n * event that they disconnect and need to backfill, they can detect re-orgs.\r\n * Keep a buffer that goes back at least these many blocks, the maximum amount\r\n * at which we might conceivably see a re-org.\r\n *\r\n * Note that while our buffer goes back this many blocks, it may contain more\r\n * than this many elements, since in the case of logs subscriptions more than\r\n * one event may be emitted for a block.\r\n */\r\nconst RETAINED_EVENT_BLOCK_COUNT = 10;\r\n/**\r\n * SDK's custom implementation fo the ethers.js's 'AlchemyWebSocketProvider'.\r\n *\r\n * Do not call this constructor directly. Instead, instantiate an instance of\r\n * {@link Alchemy} and call {@link Alchemy.config.getWebSocketProvider()}.\r\n *\r\n * @public\r\n */\r\nclass AlchemyWebSocketProvider extends WebSocketProvider {\r\n    /** @internal */\r\n    constructor(config, wsConstructor) {\r\n        var _a;\r\n        // Normalize the API Key to a string.\r\n        const apiKey = AlchemyProvider.getApiKey(config.apiKey);\r\n        // Generate our own connection info with the correct endpoint URLs.\r\n        const alchemyNetwork = AlchemyProvider.getAlchemyNetwork(config.network);\r\n        const connection = AlchemyProvider.getAlchemyConnectionInfo(alchemyNetwork, apiKey, 'wss');\r\n        const protocol = `alchemy-sdk-${VERSION}`;\r\n        // Use the provided config URL override if it exists, otherwise use the created one.\r\n        const ws = new SturdyWebSocket((_a = config.url) !== null && _a !== void 0 ? _a : connection.url, protocol, {\r\n            wsConstructor: wsConstructor !== null && wsConstructor !== void 0 ? wsConstructor : getWebsocketConstructor()\r\n        });\r\n        // Normalize the Alchemy named network input to the network names used by\r\n        // ethers. This allows the parent super constructor in JsonRpcProvider to\r\n        // correctly set the network.\r\n        const ethersNetwork = EthersNetwork[alchemyNetwork];\r\n        super(ws, ethersNetwork);\r\n        this._events = [];\r\n        // In the case of a WebSocket reconnection, all subscriptions are lost and we\r\n        // create new ones to replace them, but we want to create the illusion that\r\n        // the original subscriptions persist. Thus, maintain a mapping from the\r\n        // \"virtual\" subscription ids which are visible to the consumer to the\r\n        // \"physical\" subscription ids of the actual connections. This terminology is\r\n        // borrowed from virtual and physical memory, which has a similar mapping.\r\n        /** @internal */\r\n        this.virtualSubscriptionsById = new Map();\r\n        /** @internal */\r\n        this.virtualIdsByPhysicalId = new Map();\r\n        /**\r\n         * The underlying ethers {@link WebSocketProvider} already handles and emits\r\n         * messages. To allow backfilling, track all messages that are emitted.\r\n         *\r\n         * This is a field arrow function in order to preserve `this` context when\r\n         * passing the method as an event listener.\r\n         *\r\n         * @internal\r\n         */\r\n        this.handleMessage = (event) => {\r\n            const message = JSON.parse(event.data);\r\n            if (!isSubscriptionEvent(message)) {\r\n                return;\r\n            }\r\n            const physicalId = message.params.subscription;\r\n            const virtualId = this.virtualIdsByPhysicalId.get(physicalId);\r\n            if (!virtualId) {\r\n                return;\r\n            }\r\n            const subscription = this.virtualSubscriptionsById.get(virtualId);\r\n            if (subscription.method !== 'eth_subscribe') {\r\n                return;\r\n            }\r\n            switch (subscription.params[0]) {\r\n                case 'newHeads': {\r\n                    const newHeadsSubscription = subscription;\r\n                    const newHeadsMessage = message;\r\n                    const { isBackfilling, backfillBuffer } = newHeadsSubscription;\r\n                    const { result } = newHeadsMessage.params;\r\n                    if (isBackfilling) {\r\n                        addToNewHeadsEventsBuffer(backfillBuffer, result);\r\n                    }\r\n                    else if (physicalId !== virtualId) {\r\n                        // In the case of a re-opened subscription, ethers will not emit the\r\n                        // event, so the SDK has to.\r\n                        this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);\r\n                    }\r\n                    else {\r\n                        // Ethers subscription mapping will emit the event, just store it.\r\n                        this.rememberEvent(virtualId, result, getNewHeadsBlockNumber);\r\n                    }\r\n                    break;\r\n                }\r\n                case 'logs': {\r\n                    const logsSubscription = subscription;\r\n                    const logsMessage = message;\r\n                    const { isBackfilling, backfillBuffer } = logsSubscription;\r\n                    const { result } = logsMessage.params;\r\n                    if (isBackfilling) {\r\n                        addToLogsEventsBuffer(backfillBuffer, result);\r\n                    }\r\n                    else if (virtualId !== physicalId) {\r\n                        this.emitAndRememberEvent(virtualId, result, getLogsBlockNumber);\r\n                    }\r\n                    else {\r\n                        this.rememberEvent(virtualId, result, getLogsBlockNumber);\r\n                    }\r\n                    break;\r\n                }\r\n                default:\r\n                    if (physicalId !== virtualId) {\r\n                        // In the case of a re-opened subscription, ethers will not emit the\r\n                        // event, so the SDK has to.\r\n                        const { result } = message.params;\r\n                        this.emitEvent(virtualId, result);\r\n                    }\r\n            }\r\n        };\r\n        /**\r\n         * When the websocket connection reopens:\r\n         *\r\n         * 1. Resubscribe to all existing subscriptions and start backfilling\r\n         * 2. Restart heart beat.\r\n         *\r\n         * This is a field arrow function in order to preserve `this` context when\r\n         * passing the method as an event listener.\r\n         *\r\n         * @internal\r\n         */\r\n        this.handleReopen = () => {\r\n            this.virtualIdsByPhysicalId.clear();\r\n            const { cancel, isCancelled } = makeCancelToken();\r\n            this.cancelBackfill = cancel;\r\n            for (const subscription of this.virtualSubscriptionsById.values()) {\r\n                void (() => __awaiter(this, void 0, void 0, function* () {\r\n                    try {\r\n                        yield this.resubscribeAndBackfill(isCancelled, subscription);\r\n                    }\r\n                    catch (error) {\r\n                        if (!isCancelled()) {\r\n                            console.error(`Error while backfilling \"${subscription.params[0]}\" subscription. Some events may be missing.`, error);\r\n                        }\r\n                    }\r\n                }))();\r\n            }\r\n            this.startHeartbeat();\r\n        };\r\n        /**\r\n         * Cancels the heartbeat and any pending backfills being performed. This is\r\n         * called when the websocket connection goes down or is disconnected.\r\n         *\r\n         * This is a field arrow function in order to preserve `this` context when\r\n         * passing the method as an event listener.\r\n         *\r\n         * @internal\r\n         */\r\n        this.stopHeartbeatAndBackfill = () => {\r\n            if (this.heartbeatIntervalId != null) {\r\n                clearInterval(this.heartbeatIntervalId);\r\n                this.heartbeatIntervalId = undefined;\r\n            }\r\n            this.cancelBackfill();\r\n        };\r\n        this.apiKey = apiKey;\r\n        // Start heartbeat and backfiller for the websocket connection.\r\n        this.backfiller = new WebsocketBackfiller(this);\r\n        this.addSocketListeners();\r\n        this.startHeartbeat();\r\n        this.cancelBackfill = noop;\r\n    }\r\n    /**\r\n     * Overrides the `BaseProvider.getNetwork` method as implemented by ethers.js.\r\n     *\r\n     * This override allows the SDK to set the provider's network to values not\r\n     * yet supported by ethers.js.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */\r\n    static getNetwork(network) {\r\n        if (typeof network === 'string' && network in CustomNetworks) {\r\n            return CustomNetworks[network];\r\n        }\r\n        // Call the standard ethers.js getNetwork method for other networks.\r\n        return getNetwork(network);\r\n    }\r\n    /**\r\n     * Overridden implementation of ethers that includes Alchemy based subscriptions.\r\n     *\r\n     * @param eventName Event to subscribe to\r\n     * @param listener The listener function to call when the event is triggered.\r\n     * @override\r\n     * @public\r\n     */\r\n    // TODO: Override `Listener` type to get type autocompletions.\r\n    on(eventName, listener) {\r\n        return this._addEventListener(eventName, listener, false);\r\n    }\r\n    /**\r\n     * Overridden implementation of ethers that includes Alchemy based\r\n     * subscriptions. Adds a listener to the triggered for only the next\r\n     * {@link eventName} event, after which it will be removed.\r\n     *\r\n     * @param eventName Event to subscribe to\r\n     * @param listener The listener function to call when the event is triggered.\r\n     * @override\r\n     * @public\r\n     */\r\n    // TODO: Override `Listener` type to get type autocompletions.\r\n    once(eventName, listener) {\r\n        return this._addEventListener(eventName, listener, true);\r\n    }\r\n    /**\r\n     * Removes the provided {@link listener} for the {@link eventName} event. If no\r\n     * listener is provided, all listeners for the event will be removed.\r\n     *\r\n     * @param eventName Event to unlisten to.\r\n     * @param listener The listener function to remove.\r\n     * @override\r\n     * @public\r\n     */\r\n    off(eventName, listener) {\r\n        if (isAlchemyEvent(eventName)) {\r\n            return this._off(eventName, listener);\r\n        }\r\n        else {\r\n            return super.off(eventName, listener);\r\n        }\r\n    }\r\n    /**\r\n     * Remove all listeners for the provided {@link eventName} event. If no event\r\n     * is provided, all events and their listeners are removed.\r\n     *\r\n     * @param eventName The event to remove all listeners for.\r\n     * @override\r\n     * @public\r\n     */\r\n    removeAllListeners(eventName) {\r\n        if (eventName !== undefined && isAlchemyEvent(eventName)) {\r\n            return this._removeAllListeners(eventName);\r\n        }\r\n        else {\r\n            return super.removeAllListeners(eventName);\r\n        }\r\n    }\r\n    /**\r\n     * Returns the number of listeners for the provided {@link eventName} event. If\r\n     * no event is provided, the total number of listeners for all events is returned.\r\n     *\r\n     * @param eventName The event to get the number of listeners for.\r\n     * @public\r\n     * @override\r\n     */\r\n    listenerCount(eventName) {\r\n        if (eventName !== undefined && isAlchemyEvent(eventName)) {\r\n            return this._listenerCount(eventName);\r\n        }\r\n        else {\r\n            return super.listenerCount(eventName);\r\n        }\r\n    }\r\n    /**\r\n     * Returns an array of listeners for the provided {@link eventName} event. If\r\n     * no event is provided, all listeners will be included.\r\n     *\r\n     * @param eventName The event to get the listeners for.\r\n     * @public\r\n     * @override\r\n     */\r\n    listeners(eventName) {\r\n        if (eventName !== undefined && isAlchemyEvent(eventName)) {\r\n            return this._listeners(eventName);\r\n        }\r\n        else {\r\n            return super.listeners(eventName);\r\n        }\r\n    }\r\n    /**\r\n     * Overrides the method in `BaseProvider` in order to properly format the\r\n     * Alchemy subscription events.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */\r\n    _addEventListener(eventName, listener, once) {\r\n        if (isAlchemyEvent(eventName)) {\r\n            verifyAlchemyEventName(eventName);\r\n            const event = new EthersEvent(getAlchemyEventTag(eventName), listener, once);\r\n            this._events.push(event);\r\n            this._startEvent(event);\r\n            return this;\r\n        }\r\n        else {\r\n            return super._addEventListener(eventName, listener, once);\r\n        }\r\n    }\r\n    /**\r\n     * Overrides the `_startEvent()` method in ethers.js's\r\n     * {@link WebSocketProvider} to include additional alchemy methods.\r\n     *\r\n     * @param event\r\n     * @override\r\n     * @internal\r\n     */\r\n    _startEvent(event) {\r\n        // Check if the event type is a custom Alchemy subscription.\r\n        const customLogicTypes = [...ALCHEMY_EVENT_TYPES, 'block', 'filter'];\r\n        if (customLogicTypes.includes(event.type)) {\r\n            this.customStartEvent(event);\r\n        }\r\n        else {\r\n            super._startEvent(event);\r\n        }\r\n    }\r\n    /**\r\n     * Overridden from ethers.js's {@link WebSocketProvider}\r\n     *\r\n     * Modified in order to add mappings for backfilling.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */\r\n    _subscribe(tag, param, processFunc, event) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let subIdPromise = this._subIds[tag];\r\n            // BEGIN MODIFIED CODE\r\n            const startingBlockNumber = yield this.getBlockNumber();\r\n            // END MODIFIED CODE\r\n            if (subIdPromise == null) {\r\n                subIdPromise = Promise.all(param).then(param => {\r\n                    return this.send('eth_subscribe', param);\r\n                });\r\n                this._subIds[tag] = subIdPromise;\r\n            }\r\n            const subId = yield subIdPromise;\r\n            // BEGIN MODIFIED CODE\r\n            const resolvedParams = yield Promise.all(param);\r\n            this.virtualSubscriptionsById.set(subId, {\r\n                event: event,\r\n                method: 'eth_subscribe',\r\n                params: resolvedParams,\r\n                startingBlockNumber,\r\n                virtualId: subId,\r\n                physicalId: subId,\r\n                sentEvents: [],\r\n                isBackfilling: false,\r\n                backfillBuffer: []\r\n            });\r\n            this.virtualIdsByPhysicalId.set(subId, subId);\r\n            // END MODIFIED CODE\r\n            this._subs[subId] = { tag, processFunc };\r\n        });\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @internal\r\n     * @override\r\n     */\r\n    emit(eventName, ...args) {\r\n        if (isAlchemyEvent(eventName)) {\r\n            let result = false;\r\n            const stopped = [];\r\n            // This line is the only modified line from the original method.\r\n            const eventTag = getAlchemyEventTag(eventName);\r\n            this._events = this._events.filter(event => {\r\n                if (event.tag !== eventTag) {\r\n                    return true;\r\n                }\r\n                setTimeout(() => {\r\n                    event.listener.apply(this, args);\r\n                }, 0);\r\n                result = true;\r\n                if (event.once) {\r\n                    stopped.push(event);\r\n                    return false;\r\n                }\r\n                return true;\r\n            });\r\n            stopped.forEach(event => {\r\n                this._stopEvent(event);\r\n            });\r\n            return result;\r\n        }\r\n        else {\r\n            return super.emit(eventName, ...args);\r\n        }\r\n    }\r\n    /** @internal */\r\n    sendBatch(parts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let nextId = 0;\r\n            const payload = parts.map(({ method, params }) => {\r\n                return {\r\n                    method,\r\n                    params,\r\n                    jsonrpc: '2.0',\r\n                    id: `alchemy-sdk:${nextId++}`\r\n                };\r\n            });\r\n            return this.sendBatchConcurrently(payload);\r\n        });\r\n    }\r\n    /** @override */\r\n    destroy() {\r\n        this.removeSocketListeners();\r\n        this.stopHeartbeatAndBackfill();\r\n        return super.destroy();\r\n    }\r\n    /**\r\n     * Overrides the ether's `isCommunityResource()` method. Returns true if the\r\n     * current api key is the default key.\r\n     *\r\n     * @override\r\n     */\r\n    isCommunityResource() {\r\n        return this.apiKey === DEFAULT_ALCHEMY_API_KEY;\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `WebSocketProvider._stopEvent()`.\r\n     *\r\n     * This method is copied over directly in order to support Alchemy's\r\n     * subscription type by allowing the provider to properly stop Alchemy's\r\n     * subscription events.\r\n     *\r\n     * @internal\r\n     */\r\n    _stopEvent(event) {\r\n        let tag = event.tag;\r\n        // START MODIFIED CODE\r\n        if (ALCHEMY_EVENT_TYPES.includes(event.type)) {\r\n            // There are remaining pending transaction listeners.\r\n            if (this._events.filter(e => ALCHEMY_EVENT_TYPES.includes(e.type)).length) {\r\n                return;\r\n            }\r\n            // END MODIFIED CODE\r\n        }\r\n        else if (event.type === 'tx') {\r\n            // There are remaining transaction event listeners\r\n            if (this._events.filter(e => e.type === 'tx').length) {\r\n                return;\r\n            }\r\n            tag = 'tx';\r\n        }\r\n        else if (this.listenerCount(event.event)) {\r\n            // There are remaining event listeners\r\n            return;\r\n        }\r\n        const subId = this._subIds[tag];\r\n        if (!subId) {\r\n            return;\r\n        }\r\n        delete this._subIds[tag];\r\n        void subId.then(subId => {\r\n            if (!this._subs[subId]) {\r\n                return;\r\n            }\r\n            delete this._subs[subId];\r\n            void this.send('eth_unsubscribe', [subId]);\r\n        });\r\n    }\r\n    /** @internal */\r\n    addSocketListeners() {\r\n        this._websocket.addEventListener('message', this.handleMessage);\r\n        this._websocket.addEventListener('reopen', this.handleReopen);\r\n        this._websocket.addEventListener('down', this.stopHeartbeatAndBackfill);\r\n    }\r\n    /** @internal */\r\n    removeSocketListeners() {\r\n        this._websocket.removeEventListener('message', this.handleMessage);\r\n        this._websocket.removeEventListener('reopen', this.handleReopen);\r\n        this._websocket.removeEventListener('down', this.stopHeartbeatAndBackfill);\r\n    }\r\n    /**\r\n     * Reopens the backfill based on\r\n     *\r\n     * @param isCancelled\r\n     * @param subscription\r\n     * @internal\r\n     */\r\n    resubscribeAndBackfill(isCancelled, subscription) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { virtualId, method, params, sentEvents, backfillBuffer, startingBlockNumber } = subscription;\r\n            subscription.isBackfilling = true;\r\n            backfillBuffer.length = 0;\r\n            try {\r\n                const physicalId = yield this.send(method, params);\r\n                throwIfCancelled(isCancelled);\r\n                subscription.physicalId = physicalId;\r\n                this.virtualIdsByPhysicalId.set(physicalId, virtualId);\r\n                switch (params[0]) {\r\n                    case 'newHeads': {\r\n                        const backfillEvents = yield withBackoffRetries(() => withTimeout(this.backfiller.getNewHeadsBackfill(isCancelled, sentEvents, startingBlockNumber), BACKFILL_TIMEOUT), BACKFILL_RETRIES, () => !isCancelled());\r\n                        throwIfCancelled(isCancelled);\r\n                        const events = dedupeNewHeads([...backfillEvents, ...backfillBuffer]);\r\n                        events.forEach(event => this.emitNewHeadsEvent(virtualId, event));\r\n                        break;\r\n                    }\r\n                    case 'logs': {\r\n                        const filter = params[1] || {};\r\n                        const backfillEvents = yield withBackoffRetries(() => withTimeout(this.backfiller.getLogsBackfill(isCancelled, filter, sentEvents, startingBlockNumber), BACKFILL_TIMEOUT), BACKFILL_RETRIES, () => !isCancelled());\r\n                        throwIfCancelled(isCancelled);\r\n                        const events = dedupeLogs([...backfillEvents, ...backfillBuffer]);\r\n                        events.forEach(event => this.emitLogsEvent(virtualId, event));\r\n                        break;\r\n                    }\r\n                    default:\r\n                        break;\r\n                }\r\n            }\r\n            finally {\r\n                subscription.isBackfilling = false;\r\n                backfillBuffer.length = 0;\r\n            }\r\n        });\r\n    }\r\n    /** @internal */\r\n    emitNewHeadsEvent(virtualId, result) {\r\n        this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);\r\n    }\r\n    /** @internal */\r\n    emitLogsEvent(virtualId, result) {\r\n        this.emitAndRememberEvent(virtualId, result, getLogsBlockNumber);\r\n    }\r\n    /**\r\n     * Emits an event to consumers, but also remembers it in its subscriptions's\r\n     * `sentEvents` buffer so that we can detect re-orgs if the connection drops\r\n     * and needs to be reconnected.\r\n     *\r\n     * @internal\r\n     */\r\n    emitAndRememberEvent(virtualId, result, getBlockNumber) {\r\n        this.rememberEvent(virtualId, result, getBlockNumber);\r\n        this.emitEvent(virtualId, result);\r\n    }\r\n    emitEvent(virtualId, result) {\r\n        const subscription = this.virtualSubscriptionsById.get(virtualId);\r\n        if (!subscription) {\r\n            return;\r\n        }\r\n        this.emitGenericEvent(subscription, result);\r\n    }\r\n    /** @internal */\r\n    rememberEvent(virtualId, result, getBlockNumber) {\r\n        const subscription = this.virtualSubscriptionsById.get(virtualId);\r\n        if (!subscription) {\r\n            return;\r\n        }\r\n        // Web3 modifies these event objects once we pass them on (changing hex\r\n        // numbers to numbers). We want the original event, so make a defensive\r\n        // copy.\r\n        addToPastEventsBuffer(subscription.sentEvents, Object.assign({}, result), getBlockNumber);\r\n    }\r\n    /** @internal */\r\n    emitGenericEvent(subscription, result) {\r\n        const emitFunction = this.emitProcessFn(subscription.event);\r\n        emitFunction(result);\r\n    }\r\n    /**\r\n     * Starts a heartbeat that pings the websocket server periodically to ensure\r\n     * that the connection stays open.\r\n     *\r\n     * @internal\r\n     */\r\n    startHeartbeat() {\r\n        if (this.heartbeatIntervalId != null) {\r\n            return;\r\n        }\r\n        this.heartbeatIntervalId = setInterval(() => __awaiter(this, void 0, void 0, function* () {\r\n            try {\r\n                yield withTimeout(this.send('net_version'), HEARTBEAT_WAIT_TIME);\r\n            }\r\n            catch (_a) {\r\n                this._websocket.reconnect();\r\n            }\r\n        }), HEARTBEAT_INTERVAL);\r\n    }\r\n    /**\r\n     * This method sends the batch concurrently as individual requests rather than\r\n     * as a batch, which was the original implementation. The original batch logic\r\n     * is preserved in this implementation in order for faster porting.\r\n     *\r\n     * @param payload\r\n     * @internal\r\n     */\r\n    // TODO(cleanup): Refactor and remove usages of `sendBatch()`.\r\n    // TODO(errors): Use allSettled() once we have more error handling.\r\n    sendBatchConcurrently(payload) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return Promise.all(payload.map(req => this.send(req.method, req.params)));\r\n        });\r\n    }\r\n    /** @internal */\r\n    customStartEvent(event) {\r\n        if (event.type === ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE) {\r\n            const { fromAddress, toAddress, hashesOnly } = event;\r\n            void this._subscribe(event.tag, [\r\n                AlchemySubscription.PENDING_TRANSACTIONS,\r\n                { fromAddress, toAddress, hashesOnly }\r\n            ], this.emitProcessFn(event), event);\r\n        }\r\n        else if (event.type === ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE) {\r\n            const { addresses, includeRemoved, hashesOnly } = event;\r\n            void this._subscribe(event.tag, [\r\n                AlchemySubscription.MINED_TRANSACTIONS,\r\n                { addresses, includeRemoved, hashesOnly }\r\n            ], this.emitProcessFn(event), event);\r\n        }\r\n        else if (event.type === 'block') {\r\n            void this._subscribe('block', ['newHeads'], this.emitProcessFn(event), event);\r\n        }\r\n        else if (event.type === 'filter') {\r\n            void this._subscribe(event.tag, ['logs', this._getFilter(event.filter)], this.emitProcessFn(event), event);\r\n        }\r\n    }\r\n    /** @internal */\r\n    emitProcessFn(event) {\r\n        switch (event.type) {\r\n            case ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE:\r\n                return result => this.emit({\r\n                    method: AlchemySubscription.PENDING_TRANSACTIONS,\r\n                    fromAddress: event.fromAddress,\r\n                    toAddress: event.toAddress,\r\n                    hashesOnly: event.hashesOnly\r\n                }, result);\r\n            case ALCHEMY_MINED_TRANSACTIONS_EVENT_TYPE:\r\n                return result => this.emit({\r\n                    method: AlchemySubscription.MINED_TRANSACTIONS,\r\n                    addresses: event.addresses,\r\n                    includeRemoved: event.includeRemoved,\r\n                    hashesOnly: event.hashesOnly\r\n                }, result);\r\n            case 'block':\r\n                return result => {\r\n                    const blockNumber = BigNumber.from(result.number).toNumber();\r\n                    this._emitted.block = blockNumber;\r\n                    this.emit('block', blockNumber);\r\n                };\r\n            case 'filter':\r\n                return result => {\r\n                    if (result.removed == null) {\r\n                        result.removed = false;\r\n                    }\r\n                    this.emit(event.filter, this.formatter.filterLog(result));\r\n                };\r\n            default:\r\n                throw new Error('Invalid event type to `emitProcessFn()`');\r\n        }\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider.off()`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @private\r\n     */\r\n    _off(eventName, listener) {\r\n        if (listener == null) {\r\n            return this.removeAllListeners(eventName);\r\n        }\r\n        const stopped = [];\r\n        let found = false;\r\n        const eventTag = getAlchemyEventTag(eventName);\r\n        this._events = this._events.filter(event => {\r\n            if (event.tag !== eventTag || event.listener != listener) {\r\n                return true;\r\n            }\r\n            if (found) {\r\n                return true;\r\n            }\r\n            found = true;\r\n            stopped.push(event);\r\n            return false;\r\n        });\r\n        stopped.forEach(event => {\r\n            this._stopEvent(event);\r\n        });\r\n        return this;\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider.removeAllListeners()`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @private\r\n     */\r\n    _removeAllListeners(eventName) {\r\n        let stopped = [];\r\n        if (eventName == null) {\r\n            stopped = this._events;\r\n            this._events = [];\r\n        }\r\n        else {\r\n            const eventTag = getAlchemyEventTag(eventName);\r\n            this._events = this._events.filter(event => {\r\n                if (event.tag !== eventTag) {\r\n                    return true;\r\n                }\r\n                stopped.push(event);\r\n                return false;\r\n            });\r\n        }\r\n        stopped.forEach(event => {\r\n            this._stopEvent(event);\r\n        });\r\n        return this;\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider.listenerCount()`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @private\r\n     */\r\n    _listenerCount(eventName) {\r\n        if (!eventName) {\r\n            return this._events.length;\r\n        }\r\n        const eventTag = getAlchemyEventTag(eventName);\r\n        return this._events.filter(event => {\r\n            return event.tag === eventTag;\r\n        }).length;\r\n    }\r\n    /**\r\n     * DO NOT MODIFY.\r\n     *\r\n     * Original code copied over from ether.js's `BaseProvider.listeners()`.\r\n     *\r\n     * This method is copied over directly in order to implement Alchemy's unique\r\n     * subscription types. The only difference is that this method calls\r\n     * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\r\n     * order to parse the Alchemy subscription event.\r\n     *\r\n     * @private\r\n     */\r\n    _listeners(eventName) {\r\n        if (eventName == null) {\r\n            return this._events.map(event => event.listener);\r\n        }\r\n        const eventTag = getAlchemyEventTag(eventName);\r\n        return this._events\r\n            .filter(event => event.tag === eventTag)\r\n            .map(event => event.listener);\r\n    }\r\n}\r\nfunction getWebsocketConstructor() {\r\n    return isNodeEnvironment() ? require('websocket').w3cwebsocket : WebSocket;\r\n}\r\nfunction isNodeEnvironment() {\r\n    return (typeof process !== 'undefined' &&\r\n        process != null &&\r\n        process.versions != null &&\r\n        process.versions.node != null);\r\n}\r\n// TODO(cleanup): Use class variable rather than passing `isCancelled` everywhere.\r\nfunction makeCancelToken() {\r\n    let cancelled = false;\r\n    return { cancel: () => (cancelled = true), isCancelled: () => cancelled };\r\n}\r\n// TODO(cleanup): replace with SDK's backoff implementation\r\nconst MIN_RETRY_DELAY = 1000;\r\nconst RETRY_BACKOFF_FACTOR = 2;\r\nconst MAX_RETRY_DELAY = 30000;\r\nfunction withBackoffRetries(f, retryCount, shouldRetry = () => true) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        let nextWaitTime = 0;\r\n        let i = 0;\r\n        while (true) {\r\n            try {\r\n                return yield f();\r\n            }\r\n            catch (error) {\r\n                i++;\r\n                if (i >= retryCount || !shouldRetry(error)) {\r\n                    throw error;\r\n                }\r\n                yield delay(nextWaitTime);\r\n                if (!shouldRetry(error)) {\r\n                    throw error;\r\n                }\r\n                nextWaitTime =\r\n                    nextWaitTime === 0\r\n                        ? MIN_RETRY_DELAY\r\n                        : Math.min(MAX_RETRY_DELAY, RETRY_BACKOFF_FACTOR * nextWaitTime);\r\n            }\r\n        }\r\n    });\r\n}\r\nfunction delay(ms) {\r\n    return new Promise(resolve => setTimeout(resolve, ms));\r\n}\r\nfunction withTimeout(promise, ms) {\r\n    return Promise.race([\r\n        promise,\r\n        new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), ms))\r\n    ]);\r\n}\r\nfunction getNewHeadsBlockNumber(event) {\r\n    return fromHex(event.number);\r\n}\r\nfunction getLogsBlockNumber(event) {\r\n    return fromHex(event.blockNumber);\r\n}\r\nfunction isResponse(message) {\r\n    return (Array.isArray(message) ||\r\n        (message.jsonrpc === '2.0' && message.id !== undefined));\r\n}\r\nfunction isSubscriptionEvent(message) {\r\n    return !isResponse(message);\r\n}\r\nfunction addToNewHeadsEventsBuffer(pastEvents, event) {\r\n    addToPastEventsBuffer(pastEvents, event, getNewHeadsBlockNumber);\r\n}\r\nfunction addToLogsEventsBuffer(pastEvents, event) {\r\n    addToPastEventsBuffer(pastEvents, event, getLogsBlockNumber);\r\n}\r\n/**\r\n * Adds a new event to an array of events, evicting any events which are so old\r\n * that they will no longer feasibly be part of a reorg.\r\n */\r\nfunction addToPastEventsBuffer(pastEvents, event, getBlockNumber) {\r\n    const currentBlockNumber = getBlockNumber(event);\r\n    // Find first index of an event recent enough to retain, then drop everything\r\n    // at a lower index.\r\n    const firstGoodIndex = pastEvents.findIndex(e => getBlockNumber(e) > currentBlockNumber - RETAINED_EVENT_BLOCK_COUNT);\r\n    if (firstGoodIndex === -1) {\r\n        pastEvents.length = 0;\r\n    }\r\n    else {\r\n        pastEvents.splice(0, firstGoodIndex);\r\n    }\r\n    pastEvents.push(event);\r\n}\n\nexport { AlchemyWebSocketProvider };\n//# sourceMappingURL=alchemy-websocket-provider-35c345f7.js.map\n","var naiveFallback = function () {\n\tif (typeof self === \"object\" && self) return self;\n\tif (typeof window === \"object\" && window) return window;\n\tthrow new Error(\"Unable to resolve global `this`\");\n};\n\nmodule.exports = (function () {\n\tif (this) return this;\n\n\t// Unexpected strict mode (may happen if e.g. bundled into ESM module)\n\n\t// Fallback to standard globalThis if available\n\tif (typeof globalThis === \"object\" && globalThis) return globalThis;\n\n\t// Thanks @mathiasbynens -> https://mathiasbynens.be/notes/globalthis\n\t// In all ES5+ engines global object inherits from Object.prototype\n\t// (if you approached one that doesn't please report)\n\ttry {\n\t\tObject.defineProperty(Object.prototype, \"__global__\", {\n\t\t\tget: function () { return this; },\n\t\t\tconfigurable: true\n\t\t});\n\t} catch (error) {\n\t\t// Unfortunate case of updates to Object.prototype being restricted\n\t\t// via preventExtensions, seal or freeze\n\t\treturn naiveFallback();\n\t}\n\ttry {\n\t\t// Safari case (window.__global__ works, but __global__ does not)\n\t\tif (!__global__) return naiveFallback();\n\t\treturn __global__;\n\t} finally {\n\t\tdelete Object.prototype.__global__;\n\t}\n})();\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SHOULD_RECONNECT_FALSE_MESSAGE = \"Provided shouldReconnect() returned false. Closing permanently.\";\nvar SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE = \"Provided shouldReconnect() resolved to false. Closing permanently.\";\nvar SturdyWebSocket = /** @class */ (function () {\n    function SturdyWebSocket(url, protocolsOrOptions, options) {\n        if (options === void 0) { options = {}; }\n        this.url = url;\n        this.onclose = null;\n        this.onerror = null;\n        this.onmessage = null;\n        this.onopen = null;\n        this.ondown = null;\n        this.onreopen = null;\n        this.CONNECTING = SturdyWebSocket.CONNECTING;\n        this.OPEN = SturdyWebSocket.OPEN;\n        this.CLOSING = SturdyWebSocket.CLOSING;\n        this.CLOSED = SturdyWebSocket.CLOSED;\n        this.hasBeenOpened = false;\n        this.isClosed = false;\n        this.messageBuffer = [];\n        this.nextRetryTime = 0;\n        this.reconnectCount = 0;\n        this.lastKnownExtensions = \"\";\n        this.lastKnownProtocol = \"\";\n        this.listeners = {};\n        if (protocolsOrOptions == null ||\n            typeof protocolsOrOptions === \"string\" ||\n            Array.isArray(protocolsOrOptions)) {\n            this.protocols = protocolsOrOptions;\n        }\n        else {\n            options = protocolsOrOptions;\n        }\n        this.options = applyDefaultOptions(options);\n        if (!this.options.wsConstructor) {\n            if (typeof WebSocket !== \"undefined\") {\n                this.options.wsConstructor = WebSocket;\n            }\n            else {\n                throw new Error(\"WebSocket not present in global scope and no \" +\n                    \"wsConstructor option was provided.\");\n            }\n        }\n        this.openNewWebSocket();\n    }\n    Object.defineProperty(SturdyWebSocket.prototype, \"binaryType\", {\n        get: function () {\n            return this.binaryTypeInternal || \"blob\";\n        },\n        set: function (binaryType) {\n            this.binaryTypeInternal = binaryType;\n            if (this.ws) {\n                this.ws.binaryType = binaryType;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SturdyWebSocket.prototype, \"bufferedAmount\", {\n        get: function () {\n            var sum = this.ws ? this.ws.bufferedAmount : 0;\n            var hasUnknownAmount = false;\n            this.messageBuffer.forEach(function (data) {\n                var byteLength = getDataByteLength(data);\n                if (byteLength != null) {\n                    sum += byteLength;\n                }\n                else {\n                    hasUnknownAmount = true;\n                }\n            });\n            if (hasUnknownAmount) {\n                this.debugLog(\"Some buffered data had unknown length. bufferedAmount()\" +\n                    \" return value may be below the correct amount.\");\n            }\n            return sum;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SturdyWebSocket.prototype, \"extensions\", {\n        get: function () {\n            return this.ws ? this.ws.extensions : this.lastKnownExtensions;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SturdyWebSocket.prototype, \"protocol\", {\n        get: function () {\n            return this.ws ? this.ws.protocol : this.lastKnownProtocol;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SturdyWebSocket.prototype, \"readyState\", {\n        get: function () {\n            return this.isClosed ? SturdyWebSocket.CLOSED : SturdyWebSocket.OPEN;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    SturdyWebSocket.prototype.close = function (code, reason) {\n        this.disposeSocket(code, reason);\n        this.shutdown();\n        this.debugLog(\"WebSocket permanently closed by client.\");\n    };\n    SturdyWebSocket.prototype.send = function (data) {\n        if (this.isClosed) {\n            throw new Error(\"WebSocket is already in CLOSING or CLOSED state.\");\n        }\n        else if (this.ws && this.ws.readyState === this.OPEN) {\n            this.ws.send(data);\n        }\n        else {\n            this.messageBuffer.push(data);\n        }\n    };\n    SturdyWebSocket.prototype.reconnect = function () {\n        if (this.isClosed) {\n            throw new Error(\"Cannot call reconnect() on socket which is permanently closed.\");\n        }\n        this.disposeSocket(1000, \"Client requested reconnect.\");\n        this.handleClose(undefined);\n    };\n    SturdyWebSocket.prototype.addEventListener = function (type, listener) {\n        if (!this.listeners[type]) {\n            this.listeners[type] = [];\n        }\n        this.listeners[type].push(listener);\n    };\n    SturdyWebSocket.prototype.dispatchEvent = function (event) {\n        return this.dispatchEventOfType(event.type, event);\n    };\n    SturdyWebSocket.prototype.removeEventListener = function (type, listener) {\n        if (this.listeners[type]) {\n            this.listeners[type] = this.listeners[type].filter(function (l) { return l !== listener; });\n        }\n    };\n    SturdyWebSocket.prototype.openNewWebSocket = function () {\n        var _this = this;\n        if (this.isClosed) {\n            return;\n        }\n        var _a = this.options, connectTimeout = _a.connectTimeout, wsConstructor = _a.wsConstructor;\n        this.debugLog(\"Opening new WebSocket to \" + this.url + \".\");\n        var ws = new wsConstructor(this.url, this.protocols);\n        ws.onclose = function (event) { return _this.handleClose(event); };\n        ws.onerror = function (event) { return _this.handleError(event); };\n        ws.onmessage = function (event) { return _this.handleMessage(event); };\n        ws.onopen = function (event) { return _this.handleOpen(event); };\n        this.connectTimeoutId = setTimeout(function () {\n            // If this is running, we still haven't opened the websocket.\n            // Kill it so we can try again.\n            _this.clearConnectTimeout();\n            _this.disposeSocket();\n            _this.handleClose(undefined);\n        }, connectTimeout);\n        this.ws = ws;\n    };\n    SturdyWebSocket.prototype.handleOpen = function (event) {\n        var _this = this;\n        if (!this.ws || this.isClosed) {\n            return;\n        }\n        var allClearResetTime = this.options.allClearResetTime;\n        this.debugLog(\"WebSocket opened.\");\n        if (this.binaryTypeInternal != null) {\n            this.ws.binaryType = this.binaryTypeInternal;\n        }\n        else {\n            this.binaryTypeInternal = this.ws.binaryType;\n        }\n        this.clearConnectTimeout();\n        if (this.hasBeenOpened) {\n            this.dispatchEventOfType(\"reopen\", event);\n        }\n        else {\n            this.dispatchEventOfType(\"open\", event);\n            this.hasBeenOpened = true;\n        }\n        this.messageBuffer.forEach(function (message) { return _this.send(message); });\n        this.messageBuffer = [];\n        this.allClearTimeoutId = setTimeout(function () {\n            _this.clearAllClearTimeout();\n            _this.nextRetryTime = 0;\n            _this.reconnectCount = 0;\n            var openTime = (allClearResetTime / 1000) | 0;\n            _this.debugLog(\"WebSocket remained open for \" + openTime + \" seconds. Resetting\" +\n                \" retry time and count.\");\n        }, allClearResetTime);\n    };\n    SturdyWebSocket.prototype.handleMessage = function (event) {\n        if (this.isClosed) {\n            return;\n        }\n        this.dispatchEventOfType(\"message\", event);\n    };\n    SturdyWebSocket.prototype.handleClose = function (event) {\n        var _this = this;\n        if (this.isClosed) {\n            return;\n        }\n        var _a = this.options, maxReconnectAttempts = _a.maxReconnectAttempts, shouldReconnect = _a.shouldReconnect;\n        this.clearConnectTimeout();\n        this.clearAllClearTimeout();\n        if (this.ws) {\n            this.lastKnownExtensions = this.ws.extensions;\n            this.lastKnownProtocol = this.ws.protocol;\n            this.disposeSocket();\n        }\n        this.dispatchEventOfType(\"down\", event);\n        if (this.reconnectCount >= maxReconnectAttempts) {\n            this.stopReconnecting(event, this.getTooManyFailedReconnectsMessage());\n            return;\n        }\n        var willReconnect = !event || shouldReconnect(event);\n        if (typeof willReconnect === \"boolean\") {\n            this.handleWillReconnect(willReconnect, event, SHOULD_RECONNECT_FALSE_MESSAGE);\n        }\n        else {\n            willReconnect.then(function (willReconnectResolved) {\n                if (_this.isClosed) {\n                    return;\n                }\n                _this.handleWillReconnect(willReconnectResolved, event, SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE);\n            });\n        }\n    };\n    SturdyWebSocket.prototype.handleError = function (event) {\n        this.dispatchEventOfType(\"error\", event);\n        this.debugLog(\"WebSocket encountered an error.\");\n    };\n    SturdyWebSocket.prototype.handleWillReconnect = function (willReconnect, event, denialReason) {\n        if (willReconnect) {\n            this.reestablishConnection();\n        }\n        else {\n            this.stopReconnecting(event, denialReason);\n        }\n    };\n    SturdyWebSocket.prototype.reestablishConnection = function () {\n        var _this = this;\n        var _a = this.options, minReconnectDelay = _a.minReconnectDelay, maxReconnectDelay = _a.maxReconnectDelay, reconnectBackoffFactor = _a.reconnectBackoffFactor;\n        this.reconnectCount++;\n        var retryTime = this.nextRetryTime;\n        this.nextRetryTime = Math.max(minReconnectDelay, Math.min(this.nextRetryTime * reconnectBackoffFactor, maxReconnectDelay));\n        setTimeout(function () { return _this.openNewWebSocket(); }, retryTime);\n        var retryTimeSeconds = (retryTime / 1000) | 0;\n        this.debugLog(\"WebSocket was closed. Re-opening in \" + retryTimeSeconds + \" seconds.\");\n    };\n    SturdyWebSocket.prototype.stopReconnecting = function (event, debugReason) {\n        this.debugLog(debugReason);\n        this.shutdown();\n        if (event) {\n            this.dispatchEventOfType(\"close\", event);\n        }\n    };\n    SturdyWebSocket.prototype.shutdown = function () {\n        this.isClosed = true;\n        this.clearAllTimeouts();\n        this.messageBuffer = [];\n        this.disposeSocket();\n    };\n    SturdyWebSocket.prototype.disposeSocket = function (closeCode, reason) {\n        if (!this.ws) {\n            return;\n        }\n        // Use noop handlers instead of null because some WebSocket\n        // implementations, such as the one from isomorphic-ws, raise a stink on\n        // unhandled events.\n        this.ws.onerror = noop;\n        this.ws.onclose = noop;\n        this.ws.onmessage = noop;\n        this.ws.onopen = noop;\n        this.ws.close(closeCode, reason);\n        this.ws = undefined;\n    };\n    SturdyWebSocket.prototype.clearAllTimeouts = function () {\n        this.clearConnectTimeout();\n        this.clearAllClearTimeout();\n    };\n    SturdyWebSocket.prototype.clearConnectTimeout = function () {\n        if (this.connectTimeoutId != null) {\n            clearTimeout(this.connectTimeoutId);\n            this.connectTimeoutId = undefined;\n        }\n    };\n    SturdyWebSocket.prototype.clearAllClearTimeout = function () {\n        if (this.allClearTimeoutId != null) {\n            clearTimeout(this.allClearTimeoutId);\n            this.allClearTimeoutId = undefined;\n        }\n    };\n    SturdyWebSocket.prototype.dispatchEventOfType = function (type, event) {\n        var _this = this;\n        switch (type) {\n            case \"close\":\n                if (this.onclose) {\n                    this.onclose(event);\n                }\n                break;\n            case \"error\":\n                if (this.onerror) {\n                    this.onerror(event);\n                }\n                break;\n            case \"message\":\n                if (this.onmessage) {\n                    this.onmessage(event);\n                }\n                break;\n            case \"open\":\n                if (this.onopen) {\n                    this.onopen(event);\n                }\n                break;\n            case \"down\":\n                if (this.ondown) {\n                    this.ondown(event);\n                }\n                break;\n            case \"reopen\":\n                if (this.onreopen) {\n                    this.onreopen(event);\n                }\n                break;\n        }\n        if (type in this.listeners) {\n            this.listeners[type]\n                .slice()\n                .forEach(function (listener) { return _this.callListener(listener, event); });\n        }\n        return !event || !event.defaultPrevented;\n    };\n    SturdyWebSocket.prototype.callListener = function (listener, event) {\n        if (typeof listener === \"function\") {\n            listener.call(this, event);\n        }\n        else {\n            listener.handleEvent.call(this, event);\n        }\n    };\n    SturdyWebSocket.prototype.debugLog = function (message) {\n        if (this.options.debug) {\n            // tslint:disable-next-line:no-console\n            console.log(message);\n        }\n    };\n    SturdyWebSocket.prototype.getTooManyFailedReconnectsMessage = function () {\n        var maxReconnectAttempts = this.options.maxReconnectAttempts;\n        return \"Failed to reconnect after \" + maxReconnectAttempts + \" \" + pluralize(\"attempt\", maxReconnectAttempts) + \". Closing permanently.\";\n    };\n    SturdyWebSocket.DEFAULT_OPTIONS = {\n        allClearResetTime: 5000,\n        connectTimeout: 5000,\n        debug: false,\n        minReconnectDelay: 1000,\n        maxReconnectDelay: 30000,\n        maxReconnectAttempts: Number.POSITIVE_INFINITY,\n        reconnectBackoffFactor: 1.5,\n        shouldReconnect: function () { return true; },\n        wsConstructor: undefined,\n    };\n    SturdyWebSocket.CONNECTING = 0;\n    SturdyWebSocket.OPEN = 1;\n    SturdyWebSocket.CLOSING = 2;\n    SturdyWebSocket.CLOSED = 3;\n    return SturdyWebSocket;\n}());\nexports.default = SturdyWebSocket;\nfunction applyDefaultOptions(options) {\n    var result = {};\n    Object.keys(SturdyWebSocket.DEFAULT_OPTIONS).forEach(function (key) {\n        var value = options[key];\n        result[key] =\n            value === undefined\n                ? SturdyWebSocket.DEFAULT_OPTIONS[key]\n                : value;\n    });\n    return result;\n}\nfunction getDataByteLength(data) {\n    if (typeof data === \"string\") {\n        // UTF-16 strings use two bytes per character.\n        return 2 * data.length;\n    }\n    else if (data instanceof ArrayBuffer) {\n        return data.byteLength;\n    }\n    else if (data instanceof Blob) {\n        return data.size;\n    }\n    else {\n        return undefined;\n    }\n}\nfunction pluralize(s, n) {\n    return n === 1 ? s : s + \"s\";\n}\nfunction noop() {\n    // Nothing.\n}\n//# sourceMappingURL=index.js.map","var _globalThis;\nif (typeof globalThis === 'object') {\n\t_globalThis = globalThis;\n} else {\n\ttry {\n\t\t_globalThis = require('es5-ext/global');\n\t} catch (error) {\n\t} finally {\n\t\tif (!_globalThis && typeof window !== 'undefined') { _globalThis = window; }\n\t\tif (!_globalThis) { throw new Error('Could not determine global this'); }\n\t}\n}\n\nvar NativeWebSocket = _globalThis.WebSocket || _globalThis.MozWebSocket;\nvar websocket_version = require('./version');\n\n\n/**\n * Expose a W3C WebSocket class with just one or two arguments.\n */\nfunction W3CWebSocket(uri, protocols) {\n\tvar native_instance;\n\n\tif (protocols) {\n\t\tnative_instance = new NativeWebSocket(uri, protocols);\n\t}\n\telse {\n\t\tnative_instance = new NativeWebSocket(uri);\n\t}\n\n\t/**\n\t * 'native_instance' is an instance of nativeWebSocket (the browser's WebSocket\n\t * class). Since it is an Object it will be returned as it is when creating an\n\t * instance of W3CWebSocket via 'new W3CWebSocket()'.\n\t *\n\t * ECMAScript 5: http://bclary.com/2004/11/07/#a-13.2.2\n\t */\n\treturn native_instance;\n}\nif (NativeWebSocket) {\n\t['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'].forEach(function(prop) {\n\t\tObject.defineProperty(W3CWebSocket, prop, {\n\t\t\tget: function() { return NativeWebSocket[prop]; }\n\t\t});\n\t});\n}\n\n/**\n * Module exports.\n */\nmodule.exports = {\n    'w3cwebsocket' : NativeWebSocket ? W3CWebSocket : null,\n    'version'      : websocket_version\n};\n","module.exports = require('../package.json').version;\n"],"names":["WS","WebSocket","Error","error","logger","throwError","operation","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","NextId","WebSocketProvider","constructor","url","network","super","this","_pollingInterval","_wsReady","connection","detectNetwork","websocket","onopen","Object","keys","_requests","forEach","id","send","payload","onmessage","messageEvent","data","JSON","parse","String","request","undefined","callback","emit","action","response","provider","message","code","method","sub","_subs","params","subscription","processFunc","console","warn","fauxPoll","setInterval","unref","_websocket","_detectNetwork","pollingInterval","resetEventsBlock","blockNumber","poll","polling","rid","stringify","jsonrpc","static","_subscribe","tag","param","subIdPromise","_subIds","all","subId","_startEvent","event","type","number","toNumber","_emitted","block","_getFilter","filter","removed","formatter","filterLog","emitReceipt","hash","getTransactionReceipt","receipt","_events","log","_stopEvent","length","listenerCount","destroy","readyState","onerror","close","WebsocketBackfiller","maxBackfillBlocks","getNewHeadsBackfill","isCancelled","previousHeads","fromBlockNumber","_","throwIfCancelled","toBlockNumber","getBlockNumber","getHeadEventsInRange","Math","max","lastSeenBlockNumber","f","minBlockNumber","reorgHeads","getReorgHeads","intermediateHeads","getLogsBackfill","previousLogs","getLogsInRange","commonAncestor","getCommonAncestor","removedLogs","map","assign","fromBlockInclusive","Number","NEGATIVE_INFINITY","addedLogs","logIndex","setMaxBackfillBlock","newMax","blockNumberHex","toBlockExclusive","batchParts","i","push","t","sendBatch","toNewHeadsEvent","oldEvent","blockHead","getBlockByNumber","reverse","oldLog","blockHash","rangeFilter","fromBlock","toBlock","head","totalDifficulty","transactions","uncles","dedupe","items","getKey","keysSeen","Set","item","key","has","add","CANCELLED","AlchemyWebSocketProvider","config","wsConstructor","_a","apiKey","AlchemyProvider","alchemyNetwork","protocol","V","process","versions","node","E","virtualSubscriptionsById","Map","virtualIdsByPhysicalId","handleMessage","Array","isArray","isResponse","isSubscriptionEvent","physicalId","virtualId","get","newHeadsSubscription","newHeadsMessage","isBackfilling","backfillBuffer","pastEvents","addToPastEventsBuffer","getNewHeadsBlockNumber","addToNewHeadsEventsBuffer","emitAndRememberEvent","rememberEvent","logsSubscription","logsMessage","getLogsBlockNumber","addToLogsEventsBuffer","emitEvent","handleReopen","clear","cancel","cancelled","makeCancelToken","cancelBackfill","values","resubscribeAndBackfill","startHeartbeat","stopHeartbeatAndBackfill","heartbeatIntervalId","clearInterval","backfiller","addSocketListeners","n","C","on","eventName","listener","_addEventListener","once","off","_off","removeAllListeners","_removeAllListeners","_listenerCount","listeners","_listeners","v","A","includes","customStartEvent","startingBlockNumber","resolvedParams","set","sentEvents","args","stopped","eventTag","setTimeout","parts","nextId","sendBatchConcurrently","removeSocketListeners","isCommunityResource","D","addEventListener","removeEventListener","backfillEvents","withBackoffRetries","withTimeout","events","emitNewHeadsEvent","dedupeLogs","emitLogsEvent","emitGenericEvent","emitProcessFn","emitFunction","reconnect","req","fromAddress","toAddress","hashesOnly","addresses","includeRemoved","found","retryCount","shouldRetry","nextWaitTime","delay","min","ms","promise","race","currentBlockNumber","firstGoodIndex","findIndex","splice","naiveFallback","self","window","module","exports","globalThis","defineProperty","prototype","configurable","__global__","SturdyWebSocket","protocolsOrOptions","options","onclose","ondown","onreopen","CONNECTING","OPEN","CLOSING","CLOSED","hasBeenOpened","isClosed","messageBuffer","nextRetryTime","reconnectCount","lastKnownExtensions","lastKnownProtocol","protocols","applyDefaultOptions","openNewWebSocket","binaryTypeInternal","binaryType","ws","enumerable","sum","bufferedAmount","hasUnknownAmount","byteLength","ArrayBuffer","Blob","size","getDataByteLength","debugLog","extensions","reason","disposeSocket","shutdown","handleClose","dispatchEvent","dispatchEventOfType","l","_this","connectTimeout","handleError","handleOpen","connectTimeoutId","clearConnectTimeout","allClearResetTime","allClearTimeoutId","clearAllClearTimeout","openTime","maxReconnectAttempts","shouldReconnect","stopReconnecting","getTooManyFailedReconnectsMessage","willReconnect","handleWillReconnect","willReconnectResolved","denialReason","reestablishConnection","minReconnectDelay","maxReconnectDelay","reconnectBackoffFactor","retryTime","retryTimeSeconds","debugReason","clearAllTimeouts","closeCode","noop","clearTimeout","slice","callListener","defaultPrevented","call","handleEvent","debug","s","DEFAULT_OPTIONS","POSITIVE_INFINITY","_globalThis","NativeWebSocket","MozWebSocket","websocket_version","W3CWebSocket","uri","prop"],"sourceRoot":""}